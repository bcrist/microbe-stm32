//[[!! write_proc 'regz STM32G030.svd -x register_types.sx' !! 13331 ]]
//[[ ################# !! GENERATED CODE -- DO NOT MODIFY !! ################# ]]
// this file was generated by regz (microbe fork)
// https://github.com/bcrist/regz
// commit: c9d702facae4d9aa9a502d6b93732aa11ae46456
//
// device: STM32G030
// cpu: CM0

pub const VectorTable = extern struct {
    initial_stack_pointer: *const fn () callconv(.C) void,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    _reserved10: u32 = undefined,
    _reserved14: u32 = undefined,
    _reserved18: u32 = undefined,
    _reserved1C: u32 = undefined,
    _reserved20: u32 = undefined,
    _reserved24: u32 = undefined,
    _reserved28: u32 = undefined,
    SVCall: InterruptVector = unhandled,
    _reserved30: u32 = undefined,
    _reserved34: u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window watchdog interrupt
    WWDG: InterruptVector = unhandled,
    _reserved40: u32 = undefined,
    /// RTC and TAMP interrupts
    RTC_STAMP: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI line 0 and 1 interrupt
    EXTI0_1: InterruptVector = unhandled,
    /// EXTI line 2 and 3 interrupt
    EXTI2_3: InterruptVector = unhandled,
    /// EXTI line 4 to 15 interrupt
    EXTI4_15: InterruptVector = unhandled,
    _reserved44: u32 = undefined,
    /// DMA channel 1 interrupt
    DMA_Channel1: InterruptVector = unhandled,
    /// DMA channel 2 and 3 interrupts
    DMA_Channel2_3: InterruptVector = unhandled,
    /// DMA channel 4, 5 and DMAMUX
    DMA_Channel4_5: InterruptVector = unhandled,
    /// ADC interrupt (ADC combined with EXTI 17 and 18)
    ADC: InterruptVector = unhandled,
    /// TIM1 break, update, trigger
    TIM1_BRK_UP_TRG_COM: InterruptVector = unhandled,
    /// TIM1 Capture Compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    _reserved48: u32 = undefined,
    _reserved4C: u32 = undefined,
    /// TIM14 global interrupt
    TIM14: InterruptVector = unhandled,
    _reserved50: u32 = undefined,
    /// TIM16 global interrupt
    TIM16: InterruptVector = unhandled,
    /// TIM17 global interrupt
    TIM17: InterruptVector = unhandled,
    /// I2C1 global interrupt
    I2C1: InterruptVector = unhandled,
    /// I2C2 global interrupt
    I2C2: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
};

pub const InterruptType = enum(i8) {
    NMI = -10,
    HardFault = -11,
    SVCall = -12,
    PendSV = -13,
    SysTick = -14,
    WWDG = 0,
    RTC_STAMP = 2,
    FLASH = 3,
    RCC = 4,
    EXTI0_1 = 5,
    EXTI2_3 = 6,
    EXTI4_15 = 7,
    DMA_Channel1 = 9,
    DMA_Channel2_3 = 10,
    DMA_Channel4_5 = 11,
    ADC = 12,
    TIM1_BRK_UP_TRG_COM = 13,
    TIM1_CC = 14,
    TIM2 = 15,
    TIM3 = 16,
    TIM14 = 19,
    TIM16 = 21,
    TIM17 = 22,
    I2C1 = 23,
    I2C2 = 24,
    SPI1 = 25,
    SPI2 = 26,
    USART1 = 27,
    USART2 = 28,
};

pub const registers = struct {
    const rt = @import("register_types.zig");
    pub const types = rt;

    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @as(*volatile Mmio(32, packed struct {
                ENABLE: u1 = 0,
                TICKINT: u1 = 0,
                CLKSOURCE: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                COUNTFLAG: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x10));

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @as(*volatile Mmio(32, packed struct {
                RELOAD: u24 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x14));

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @as(*volatile Mmio(32, packed struct {
                CURRENT: u24 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x18));

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @as(*volatile Mmio(32, packed struct {
                TENMS: u24 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                SKEW: u1 = 0,
                NOREF: u1 = 0,
            }), @ptrFromInt(base_address + 0x1c));
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = struct {
            /// address: 0xe000e100
            /// Interrupt Set Enable Register
            pub const ISER = @as(*volatile Mmio(32, packed struct {
                WWDG: u1 = 0,
                _reserved1: u1 = 0,
                RTC_STAMP: u1 = 0,
                FLASH: u1 = 0,
                RCC: u1 = 0,
                EXTI0_1: u1 = 0,
                EXTI2_3: u1 = 0,
                EXTI4_15: u1 = 0,
                _reserved8: u1 = 0,
                DMA_Channel1: u1 = 0,
                DMA_Channel2_3: u1 = 0,
                DMA_Channel4_5: u1 = 0,
                ADC: u1 = 0,
                TIM1_BRK_UP_TRG_COM: u1 = 0,
                TIM1_CC: u1 = 0,
                TIM2: u1 = 0,
                TIM3: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                TIM14: u1 = 0,
                _reserved20: u1 = 0,
                TIM16: u1 = 0,
                TIM17: u1 = 0,
                I2C1: u1 = 0,
                I2C2: u1 = 0,
                SPI1: u1 = 0,
                SPI2: u1 = 0,
                USART1: u1 = 0,
                USART2: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x100));

            /// address: 0xe000e180
            /// Interrupt Clear Enable Register
            pub const ICER = @as(*volatile Mmio(32, packed struct {
                WWDG: u1 = 0,
                _reserved1: u1 = 0,
                RTC_STAMP: u1 = 0,
                FLASH: u1 = 0,
                RCC: u1 = 0,
                EXTI0_1: u1 = 0,
                EXTI2_3: u1 = 0,
                EXTI4_15: u1 = 0,
                _reserved8: u1 = 0,
                DMA_Channel1: u1 = 0,
                DMA_Channel2_3: u1 = 0,
                DMA_Channel4_5: u1 = 0,
                ADC: u1 = 0,
                TIM1_BRK_UP_TRG_COM: u1 = 0,
                TIM1_CC: u1 = 0,
                TIM2: u1 = 0,
                TIM3: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                TIM14: u1 = 0,
                _reserved20: u1 = 0,
                TIM16: u1 = 0,
                TIM17: u1 = 0,
                I2C1: u1 = 0,
                I2C2: u1 = 0,
                SPI1: u1 = 0,
                SPI2: u1 = 0,
                USART1: u1 = 0,
                USART2: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x180));

            /// address: 0xe000e200
            /// Interrupt Set Pending Register
            pub const ISPR = @as(*volatile Mmio(32, packed struct {
                WWDG: u1 = 0,
                _reserved1: u1 = 0,
                RTC_STAMP: u1 = 0,
                FLASH: u1 = 0,
                RCC: u1 = 0,
                EXTI0_1: u1 = 0,
                EXTI2_3: u1 = 0,
                EXTI4_15: u1 = 0,
                _reserved8: u1 = 0,
                DMA_Channel1: u1 = 0,
                DMA_Channel2_3: u1 = 0,
                DMA_Channel4_5: u1 = 0,
                ADC: u1 = 0,
                TIM1_BRK_UP_TRG_COM: u1 = 0,
                TIM1_CC: u1 = 0,
                TIM2: u1 = 0,
                TIM3: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                TIM14: u1 = 0,
                _reserved20: u1 = 0,
                TIM16: u1 = 0,
                TIM17: u1 = 0,
                I2C1: u1 = 0,
                I2C2: u1 = 0,
                SPI1: u1 = 0,
                SPI2: u1 = 0,
                USART1: u1 = 0,
                USART2: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x200));

            /// address: 0xe000e280
            /// Interrupt Clear Pending Register
            pub const ICPR = @as(*volatile Mmio(32, packed struct {
                WWDG: u1 = 0,
                _reserved1: u1 = 0,
                RTC_STAMP: u1 = 0,
                FLASH: u1 = 0,
                RCC: u1 = 0,
                EXTI0_1: u1 = 0,
                EXTI2_3: u1 = 0,
                EXTI4_15: u1 = 0,
                _reserved8: u1 = 0,
                DMA_Channel1: u1 = 0,
                DMA_Channel2_3: u1 = 0,
                DMA_Channel4_5: u1 = 0,
                ADC: u1 = 0,
                TIM1_BRK_UP_TRG_COM: u1 = 0,
                TIM1_CC: u1 = 0,
                TIM2: u1 = 0,
                TIM3: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                TIM14: u1 = 0,
                _reserved20: u1 = 0,
                TIM16: u1 = 0,
                TIM17: u1 = 0,
                I2C1: u1 = 0,
                I2C2: u1 = 0,
                SPI1: u1 = 0,
                SPI2: u1 = 0,
                USART1: u1 = 0,
                USART2: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x280));

            /// address: 0xe000e400
            /// Interrupt Priority Register
            pub const IP0 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                WWDG: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                RTC_STAMP: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                FLASH: u4 = 0,
            }), @ptrFromInt(base_address + 0x400));

            /// address: 0xe000e404
            /// Interrupt Priority Register
            pub const IP1 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                RCC: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                EXTI0_1: u4 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                EXTI2_3: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                EXTI4_15: u4 = 0,
            }), @ptrFromInt(base_address + 0x404));

            /// address: 0xe000e408
            /// Interrupt Priority Register
            pub const IP2 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                DMA_Channel1: u4 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                DMA_Channel2_3: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                DMA_Channel4_5: u4 = 0,
            }), @ptrFromInt(base_address + 0x408));

            /// address: 0xe000e40c
            /// Interrupt Priority Register
            pub const IP3 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                ADC: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                TIM1_BRK_UP_TRG_COM: u4 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                TIM1_CC: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                TIM2: u4 = 0,
            }), @ptrFromInt(base_address + 0x40c));

            /// address: 0xe000e410
            /// Interrupt Priority Register
            pub const IP4 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                TIM3: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                TIM14: u4 = 0,
            }), @ptrFromInt(base_address + 0x410));

            /// address: 0xe000e414
            /// Interrupt Priority Register
            pub const IP5 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                TIM16: u4 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                TIM17: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                I2C1: u4 = 0,
            }), @ptrFromInt(base_address + 0x414));

            /// address: 0xe000e418
            /// Interrupt Priority Register
            pub const IP6 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                I2C2: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                SPI1: u4 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                SPI2: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                USART1: u4 = 0,
            }), @ptrFromInt(base_address + 0x418));

            /// address: 0xe000e41c
            /// Interrupt Priority Register
            pub const IP7 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                USART2: u4 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0x41c));
        };

        /// System Control Block
        pub const SCB = struct {
            /// address: 0xe000ed00
            pub const CPUID = @as(*volatile Mmio(32, packed struct {
                REVISION: u4 = 0,
                PARTNO: u12 = 0,
                ARCHITECTURE: u4 = 0,
                VARIANT: u4 = 0,
                IMPLEMENTER: u8 = 0,
            }), @ptrFromInt(base_address + 0xd00));

            /// address: 0xe000ed04
            /// Interrupt Control and State Register
            pub const ICSR = @as(*volatile Mmio(32, packed struct {
                VECTACTIVE: u9 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                VECTPENDING: u9 = 0,
                _reserved21: u1 = 0,
                ISRPENDING: u1 = 0,
                ISRPREEMPT: u1 = 0,
                _reserved24: u1 = 0,
                PENDSTCLR: u1 = 0,
                PENDSTSET: u1 = 0,
                PENDSVCLR: u1 = 0,
                PENDSVSET: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                NMIPENDSET: u1 = 0,
            }), @ptrFromInt(base_address + 0xd04));

            /// address: 0xe000ed0c
            /// Application Interrupt and Reset Control Register
            pub const AIRCR = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                VECTCLRACTIVE: u1 = 0,
                SYSRESETREQ: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                ENDIANESS: u1 = 0,
                VECTKEY: u16 = 0,
            }), @ptrFromInt(base_address + 0xd0c));

            /// address: 0xe000ed10
            /// System Control Register
            pub const SCR = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                SLEEPONEXIT: u1 = 0,
                SLEEPDEEP: u1 = 0,
                _reserved3: u1 = 0,
                SEVONPEND: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0xd10));

            /// address: 0xe000ed14
            /// Configuration Control Register
            pub const CCR = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                UNALIGN_TRP: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                STKALIGN: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0xd14));

            /// address: 0xe000ed1c
            /// System Handlers Priority Register 2
            pub const SHPR2 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                SVCALLPRI: u4 = 0,
            }), @ptrFromInt(base_address + 0xd1c));

            /// address: 0xe000ed20
            /// System Handlers Priority Register 3
            pub const SHPR3 = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                _reserved15: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                PENDSVPRI: u4 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                SYSTICKPRI: u4 = 0,
            }), @ptrFromInt(base_address + 0xd20));

            /// address: 0xe000ed24
            /// System Handler Control and State Register
            pub const SHCSR = @as(*volatile Mmio(32, packed struct {
                _reserved0: u1 = 0,
                _reserved1: u1 = 0,
                _reserved2: u1 = 0,
                _reserved3: u1 = 0,
                _reserved4: u1 = 0,
                _reserved5: u1 = 0,
                _reserved6: u1 = 0,
                _reserved7: u1 = 0,
                _reserved8: u1 = 0,
                _reserved9: u1 = 0,
                _reserved10: u1 = 0,
                _reserved11: u1 = 0,
                _reserved12: u1 = 0,
                _reserved13: u1 = 0,
                _reserved14: u1 = 0,
                SVCALLPENDED: u1 = 0,
                _reserved16: u1 = 0,
                _reserved17: u1 = 0,
                _reserved18: u1 = 0,
                _reserved19: u1 = 0,
                _reserved20: u1 = 0,
                _reserved21: u1 = 0,
                _reserved22: u1 = 0,
                _reserved23: u1 = 0,
                _reserved24: u1 = 0,
                _reserved25: u1 = 0,
                _reserved26: u1 = 0,
                _reserved27: u1 = 0,
                _reserved28: u1 = 0,
                _reserved29: u1 = 0,
                _reserved30: u1 = 0,
                _reserved31: u1 = 0,
            }), @ptrFromInt(base_address + 0xd24));
        };
    };

    /// Analog to Digital ConverteR
    pub const ADC = struct {
        pub const base_address = 0x40012400;

        /// address: 0x40012400
        /// ADC interrupt and status register
        pub const ADC_ISR = @as(*volatile Mmio(32, packed struct {
            /// ADC ready
            /// This bit is set by hardware after the ADC has been enabled (ADEN=1) and when the
            /// ADC reaches a state where it is ready to accept conversion requests.
            /// It is cleared by software writing 1 to it.
            ADRDY: u1 = 0,
            /// End of sampling flag
            /// This bit is set by hardware during the conversion, at the end of the sampling
            /// phase.It is cleared by software by programming it to '1â.
            EOSMP: u1 = 0,
            /// End of conversion flag
            /// This bit is set by hardware at the end of each conversion of a channel when a
            /// new data result is available in the ADC_DR register. It is cleared by software
            /// writing 1 to it or by reading the ADC_DR register.
            EOC: u1 = 0,
            /// End of sequence flag
            /// This bit is set by hardware at the end of the conversion of a sequence of
            /// channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
            EOS: u1 = 0,
            /// ADC overrun
            /// This bit is set by hardware when an overrun occurs, meaning that a new
            /// conversion has complete while the EOC flag was already set. It is cleared by
            /// software writing 1 to it.
            OVR: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Analog watchdog 1 flag
            /// This bit is set by hardware when the converted voltage crosses the values
            /// programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by
            /// programming it to 1.
            AWD1: u1 = 0,
            /// Analog watchdog 2 flag
            /// This bit is set by hardware when the converted voltage crosses the values
            /// programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software
            /// programming it it.
            AWD2: u1 = 0,
            /// Analog watchdog 3 flag
            /// This bit is set by hardware when the converted voltage crosses the values
            /// programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by
            /// programming it to 1.
            AWD3: u1 = 0,
            _reserved10: u1 = 0,
            /// End Of Calibration flag
            /// This bit is set by hardware when calibration is complete. It is cleared by
            /// software writing 1 to it.
            EOCAL: u1 = 0,
            _reserved12: u1 = 0,
            /// Channel Configuration Ready flag
            /// This flag bit is set by hardware when the channel configuration is applied after
            /// programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is
            /// cleared by software by programming it to it.
            /// Note: When the software configures the channels (by programming ADC_CHSELR or
            /// changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before
            /// configuring again or starting conversions, otherwise the new configuration (or
            /// the START bit) is ignored. Once the flag is asserted, if the software needs to
            /// configure again the channels, it must clear the CCRDY flag before proceeding
            /// with a new configuration.
            CCRDY: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40012404
        /// ADC interrupt enable register
        pub const ADC_IER = @as(*volatile Mmio(32, packed struct {
            /// ADC ready interrupt enable
            /// This bit is set and cleared by software to enable/disable the ADC Ready
            /// interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            ADRDYIE: u1 = 0,
            /// End of sampling flag interrupt enable
            /// This bit is set and cleared by software to enable/disable the end of the
            /// sampling phase interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EOSMPIE: u1 = 0,
            /// End of conversion interrupt enable
            /// This bit is set and cleared by software to enable/disable the end of conversion
            /// interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EOCIE: u1 = 0,
            /// End of conversion sequence interrupt enable
            /// This bit is set and cleared by software to enable/disable the end of sequence of
            /// conversions interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EOSIE: u1 = 0,
            /// Overrun interrupt enable
            /// This bit is set and cleared by software to enable/disable the overrun interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            OVRIE: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Analog watchdog 1 interrupt enable
            /// This bit is set and cleared by software to enable/disable the analog watchdog
            /// interrupt.
            /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AWD1IE: u1 = 0,
            /// Analog watchdog 2 interrupt enable
            /// This bit is set and cleared by software to enable/disable the analog watchdog
            /// interrupt.
            /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AWD2IE: u1 = 0,
            /// Analog watchdog 3 interrupt enable
            /// This bit is set and cleared by software to enable/disable the analog watchdog
            /// interrupt.
            /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AWD3IE: u1 = 0,
            _reserved10: u1 = 0,
            /// End of calibration interrupt enable
            /// This bit is set and cleared by software to enable/disable the end of calibration
            /// interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EOCALIE: u1 = 0,
            _reserved12: u1 = 0,
            /// Channel Configuration Ready Interrupt enable
            /// This bit is set and cleared by software to enable/disable the channel
            /// configuration ready interrupt.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            CCRDYIE: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40012408
        /// ADC control register
        pub const ADC_CR = @as(*volatile Mmio(32, packed struct {
            /// ADC enable command
            /// This bit is set by software to enable the ADC. The ADC is effectively ready to
            /// operate once the ADRDY flag has been set.
            /// It is cleared by hardware when the ADC is disabled, after the execution of the
            /// ADDIS command.
            /// Note: The software is allowed to set ADEN only when all bits of ADC_CR registers
            /// are 0 (ADCAL=0, ADSTP=0, ADSTART=0, ADDIS=0 and ADEN=0)
            ADEN: u1 = 0,
            /// ADC disable command
            /// This bit is set by software to disable the ADC (ADDIS command) and put it into
            /// power-down state (OFF state).
            /// It is cleared by hardware once the ADC is effectively disabled (ADEN is also
            /// cleared by hardware at this time).
            /// Note: Setting ADDIS to '1â is only effective when ADEN=1 and ADSTART=0
            /// (which ensures that no conversion is ongoing)
            ADDIS: u1 = 0,
            /// ADC start conversion command
            /// This bit is set by software to start ADC conversion. Depending on the EXTEN
            /// [1:0] configuration bits, a conversion either starts immediately (software
            /// trigger configuration) or once a hardware trigger event occurs (hardware trigger
            /// configuration).
            /// It is cleared by hardware:
            /// In single conversion mode (CONT=0, DISCEN=0), when software trigger is selected
            /// (EXTEN=00): at the assertion of the end of Conversion Sequence (EOS) flag.
            /// In discontinuous conversion mode(CONT=0, DISCEN=1), when the software trigger is
            /// selected (EXTEN=00): at the assertion of the end of Conversion (EOC) flag.
            /// In all other cases: after the execution of the ADSTP command, at the same time
            /// as the ADSTP bit is cleared by hardware.
            /// Note: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC
            /// is enabled and there is no pending request to disable the ADC).
            /// After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is
            /// mandatory to wait until CCRDY flag is asserted before setting ADSTART,
            /// otherwise, the value written to ADSTART is ignored.
            ADSTART: u1 = 0,
            _reserved3: u1 = 0,
            /// ADC stop conversion command
            /// This bit is set by software to stop and discard an ongoing conversion (ADSTP
            /// Command).
            /// It is cleared by hardware when the conversion is effectively discarded and the
            /// ADC is ready to accept a new start conversion command.
            /// Note: Setting ADSTP to '1â is only effective when ADSTART=1 and ADDIS=0
            /// (ADC is enabled and may be converting and there is no pending request to disable
            /// the ADC)
            ADSTP: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            /// ADC Voltage Regulator Enable
            /// This bit is set by software, to enable the ADC internal voltage regulator. The
            /// voltage regulator output is available after tADCVREG_SETUP.
            /// It is cleared by software to disable the voltage regulator. It can be cleared
            /// only if ADEN is et to 0.
            /// Note: The software is allowed to program this bit field only when the ADC is
            /// disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
            ADVREGEN: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// ADC calibration
            /// This bit is set by software to start the calibration of the ADC.
            /// It is cleared by hardware after calibration is complete.
            /// Note: The software is allowed to set ADCAL only when the ADC is disabled
            /// (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
            /// The software is allowed to update the calibration factor by writing ADC_CALFACT
            /// only when ADEN=1 and ADSTART=0 (ADC enabled and no conversion is ongoing).
            ADCAL: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4001240c
        /// ADC configuration register 1
        pub const ADC_CFGR1 = @as(*volatile Mmio(32, packed struct {
            /// Direct memory access enable
            /// This bit is set and cleared by software to enable the generation of DMA
            /// requests. This allows the DMA controller to be used to manage automatically the
            /// converted data. For more details, refer to .
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            DMAEN: u1 = 0,
            /// Direct memory access configuration
            /// This bit is set and cleared by software to select between two DMA modes of
            /// operation and is effective only when DMAEN=1.
            /// For more details, refer to page351
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            DMACFG: u1 = 0,
            /// Scan sequence direction
            /// This bit is set and cleared by software to select the direction in which the
            /// channels is scanned in the sequence. It is effective only if CHSELMOD bit is
            /// cleared to 0.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            SCANDIR: u1 = 0,
            /// Data resolution
            /// These bits are written by software to select the resolution of the conversion.
            /// Note: The software is allowed to write these bits only when ADEN=0.
            RES: u2 = 0,
            /// Data alignment
            /// This bit is set and cleared by software to select right or left alignment. Refer
            /// to Data alignment and resolution (oversampling disabled: OVSE = 0) on page349
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            ALIGN: u1 = 0,
            /// External trigger selection
            /// These bits select the external event used to trigger the start of conversion
            /// (refer to External triggers for details):
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EXTSEL: u3 = 0,
            _reserved9: u1 = 0,
            /// External trigger enable and polarity selection
            /// These bits are set and cleared by software to select the external trigger
            /// polarity and enable the trigger.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            EXTEN: u2 = 0,
            /// Overrun management mode
            /// This bit is set and cleared by software and configure the way data overruns are
            /// managed.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            OVRMOD: u1 = 0,
            /// Single / continuous conversion mode
            /// This bit is set and cleared by software. If it is set, conversion takes place
            /// continuously until it is cleared.
            /// Note: It is not possible to have both discontinuous mode and continuous mode
            /// enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.
            /// The software is allowed to write this bit only when ADSTART bit is cleared to 0
            /// (this ensures that no conversion is ongoing).
            CONT: u1 = 0,
            /// Wait conversion mode
            /// This bit is set and cleared by software to enable/disable wait conversion mode..
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            WAIT: u1 = 0,
            /// Auto-off mode
            /// This bit is set and cleared by software to enable/disable auto-off mode..
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AUTOFF: u1 = 0,
            /// Discontinuous mode
            /// This bit is set and cleared by software to enable/disable discontinuous mode.
            /// Note: It is not possible to have both discontinuous mode and continuous mode
            /// enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.
            /// The software is allowed to write this bit only when ADSTART bit is cleared to 0
            /// (this ensures that no conversion is ongoing).
            DISCEN: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            /// Mode selection of the ADC_CHSELR register
            /// This bit is set and cleared by software to control the ADC_CHSELR feature:
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSELRMOD: u1 = 0,
            /// Enable the watchdog on a single channel or on all channels
            /// This bit is set and cleared by software to enable the analog watchdog on the
            /// channel identified by the AWDCH[4:0] bits or on all the channels
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AWD1SGL: u1 = 0,
            /// Analog watchdog enable
            /// This bit is set and cleared by software.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            AWD1EN: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They select the input channel to be
            /// guarded by the analog watchdog.
            /// .....
            /// Others: Reserved
            /// Note: The channel selected by the AWDCH[4:0] bits must be also set into the
            /// CHSELR register.
            /// The software is allowed to write this bit only when ADSTART bit is cleared to 0
            /// (this ensures that no conversion is ongoing).
            AWD1CH: u5 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40012410
        /// ADC configuration register 2
        pub const ADC_CFGR2 = @as(*volatile Mmio(32, packed struct {
            /// Oversampler Enable
            /// This bit is set and cleared by software.
            /// Note: Software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            OVSE: u1 = 0,
            _reserved1: u1 = 0,
            /// Oversampling ratio
            /// This bit filed defines the number of oversampling ratio.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            OVSR: u3 = 0,
            /// Oversampling shift
            /// This bit is set and cleared by software.
            /// Others: Reserved
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            OVSS: u4 = 0,
            /// Triggered Oversampling
            /// This bit is set and cleared by software.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            TOVS: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            /// Low frequency trigger mode enable
            /// This bit is set and cleared by software.
            /// Note: The software is allowed to write this bit only when ADSTART bit is cleared
            /// to 0 (this ensures that no conversion is ongoing).
            LFTRIG: u1 = 0,
            /// ADC clock mode
            /// These bits are set and cleared by software to define how the analog ADC is
            /// clocked:
            /// In all synchronous clock modes, there is no jitter in the delay from a timer
            /// trigger to the start of a conversion.
            /// Note: The software is allowed to write these bits only when the ADC is disabled
            /// (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
            CKMODE: u2 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40012414
        /// ADC sampling time register
        pub const ADC_SMPR = @as(*volatile Mmio(32, packed struct {
            /// Sampling time selection 1
            /// These bits are written by software to select the sampling time that applies to
            /// all channels.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMP1: u3 = 0,
            _reserved3: u1 = 0,
            /// Sampling time selection 2
            /// These bits are written by software to select the sampling time that applies to
            /// all channels.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMP2: u3 = 0,
            _reserved7: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL0: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL1: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL2: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL3: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL4: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL5: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL6: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL7: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL8: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL9: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL10: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL11: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL12: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL13: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL14: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL15: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL16: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL17: u1 = 0,
            /// Channel-x sampling time selection
            /// These bits are written by software to define which sampling time is used.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SMPSEL18: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40012420
        /// ADC watchdog threshold register
        pub const ADC_AWD1TR = @as(*volatile Mmio(32, packed struct {
            /// Analog watchdog 1 lower threshold
            /// These bits are written by software to define the lower threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            LT1: u12 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Analog watchdog 1 higher threshold
            /// These bits are written by software to define the higher threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            HT1: u12 = 4095,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40012424
        /// ADC watchdog threshold register
        pub const ADC_AWD2TR = @as(*volatile Mmio(32, packed struct {
            /// Analog watchdog 2 lower threshold
            /// These bits are written by software to define the lower threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            LT2: u12 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Analog watchdog 2 higher threshold
            /// These bits are written by software to define the higher threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            HT2: u12 = 4095,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40012428
        /// ADC channel selection register [alternate]
        pub const ADC_CHSELR_0 = @as(*volatile Mmio(32, packed struct {
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL0: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL1: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL2: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL3: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL4: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL5: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL6: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL7: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL8: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL9: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL10: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL11: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL12: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL13: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL14: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL15: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL16: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL17: u1 = 0,
            /// Channel-x selection
            /// These bits are written by software and define which channels are part of the
            /// sequence of channels to be converted. Refer to for ADC inputs connected to
            /// external channels and internal sources.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR
            /// register or changing CHSELRMOD or SCANDIR), the value written to this bit is
            /// ignored.
            CHSEL18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));

        /// address: 0x40012428
        /// channel selection register CHSELRMOD = 1 in ADC_CFGR1
        pub const ADC_CHSELR_1 = @as(*volatile Mmio(32, packed struct {
            /// 1st conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ1: u4 = 0,
            /// 2nd conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ2: u4 = 0,
            /// 3rd conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ3: u4 = 0,
            /// 4th conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ4: u4 = 0,
            /// 5th conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ5: u4 = 0,
            /// 6th conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ6: u4 = 0,
            /// 7th conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// Refer to SQ8[3:0] for a definition of channel selection.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ7: u4 = 0,
            /// 8th conversion of the sequence
            /// These bits are programmed by software with the channel number (0...14) assigned
            /// to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.
            /// When 0b1111 (end of sequence) is programmed to the lower sequence channels,
            /// these bits are ignored.
            /// ...
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing).
            SQ8: u4 = 0,
        }), @ptrFromInt(base_address + 0x28));

        /// address: 0x4001242c
        /// ADC watchdog threshold register
        pub const ADC_AWD3TR = @as(*volatile Mmio(32, packed struct {
            /// Analog watchdog 3lower threshold
            /// These bits are written by software to define the lower threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            LT3: u12 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Analog watchdog 3 higher threshold
            /// These bits are written by software to define the higher threshold for the analog
            /// watchdog.
            /// Refer to ADC_AWDxTR) on page355.
            HT3: u12 = 4095,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40012440
        /// ADC data register
        pub const ADC_DR = @as(*volatile Mmio(32, packed struct {
            /// Converted data
            /// These bits are read-only. They contain the conversion result from the last
            /// converted channel. The data are left- or right-aligned as shown in OVSE = 0) on
            /// page349.
            /// Just after a calibration is complete, DATA[6:0] contains the calibration factor.
            DATA: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x400124a0
        /// ADC Analog Watchdog 2 Configuration register
        pub const ADC_AWD2CR = @as(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH0: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH1: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH2: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH3: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH4: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH5: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH6: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH7: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH8: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH9: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH10: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH11: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH12: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH13: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH14: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH15: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH16: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH17: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 2 (AWD2).
            /// Note: The channels selected through ADC_AWD2CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD2CH18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xa0));

        /// address: 0x400124a4
        /// ADC Analog Watchdog 3 Configuration register
        pub const ADC_AWD3CR = @as(*volatile Mmio(32, packed struct {
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH0: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH1: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH2: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH3: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH4: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH5: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH6: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH7: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH8: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH9: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH10: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH11: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH12: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH13: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH14: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH15: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH16: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH17: u1 = 0,
            /// Analog watchdog channel selection
            /// These bits are set and cleared by software. They enable and select the input
            /// channels to be guarded by analog watchdog 3 (AWD3).
            /// Note: The channels selected through ADC_AWD3CR must be also configured into the
            /// ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection.
            /// The software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            AWD3CH18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xa4));

        /// address: 0x400124b4
        /// ADC Calibration factor
        pub const ADC_CALFACT = @as(*volatile Mmio(32, packed struct {
            /// Calibration factor
            /// These bits are written by hardware or by software.
            /// Once a calibration is complete,they are updated by hardware with the calibration
            /// factors.
            /// Software can write these bits with a new calibration factor. If the new
            /// calibration factor is different from the current one stored into the analog ADC,
            /// it is then applied once a new calibration is launched.
            /// Just after a calibration is complete, DATA[6:0] contains the calibration factor.
            /// Note: Software can write these bits only when ADEN=1 (ADC is enabled and no
            /// calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a
            /// definition of channel selection.
            CALFACT: u7 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xb4));

        /// address: 0x40012708
        /// ADC common configuration register
        pub const ADC_CCR = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            /// ADC prescaler
            /// Set and cleared by software to select the frequency of the clock to the ADC.
            /// Other: Reserved
            /// Note: Software is allowed to write these bits only when the ADC is disabled
            /// (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
            PRESC: u4 = 0,
            /// VREFINT enable
            /// This bit is set and cleared by software to enable/disable the VREFINT.
            /// Note: Software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            VREFEN: u1 = 0,
            /// Temperature sensor enable
            /// This bit is set and cleared by software to enable/disable the temperature
            /// sensor.
            /// Note: Software is allowed to write this bit only when ADSTART=0 (which ensures
            /// that no conversion is ongoing).
            TSEN: u1 = 0,
            /// VBAT enable
            /// This bit is set and cleared by software to enable/disable the VBAT channel.
            /// Note: The software is allowed to write this bit only when ADSTART=0 (which
            /// ensures that no conversion is ongoing)
            VBATEN: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x308));
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @as(*volatile Mmio(32, packed struct {
            /// Key value (write only, read 0x0000)
            KEY: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @as(*volatile MmioInt(32, u3), @ptrFromInt(base_address + 0x4));

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @as(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload value
            RL: u12 = 4095,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000300c
        /// Status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value update
            PVU: u1 = 0,
            /// Watchdog counter reload value update
            RVU: u1 = 0,
            /// Watchdog counter window value update
            WVU: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40003010
        /// Window register
        pub const WINR = @as(*volatile Mmio(32, packed struct {
            /// Watchdog counter window value
            WIN: u12 = 4095,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));
    };

    /// System window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @as(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7 = 127,
            /// Activation bit
            WDGA: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @as(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7 = 127,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            /// Early wakeup interrupt
            EWI: u1 = 0,
            _reserved10: u1 = 0,
            /// Timer base
            WDGTB: u3 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40002c08
        /// Status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt flag
            EWIF: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));
    };

    /// Flash
    pub const FLASH = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Access control register
        pub const ACR = @as(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: rt.flash.WaitStates = fromInt(rt.flash.WaitStates, @as(u3, 0)),
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Prefetch enable
            PRFTEN: rt.flash.PrefetchEnable = fromInt(rt.flash.PrefetchEnable, @as(u1, 0)),
            /// Instruction cache enable
            ICEN: rt.flash.CacheEnable = fromInt(rt.flash.CacheEnable, @as(u1, 1)),
            _reserved10: u1 = 1,
            /// Instruction cache reset
            ICRST: rt.flash.CacheResetRequest = fromInt(rt.flash.CacheResetRequest, @as(u1, 0)),
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Flash User area empty
            EMPTY: rt.flash.EmptyFlag = fromInt(rt.flash.EmptyFlag, @as(u1, 0)),
            _reserved17: u1 = 0,
            _reserved18: u1 = 1,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40022008
        /// Flash key register
        pub const KEYR = @as(*volatile u32, @ptrFromInt(base_address + 0x8));

        /// address: 0x4002200c
        /// Option byte key register
        pub const OPTKEYR = @as(*volatile u32, @ptrFromInt(base_address + 0xc));

        /// address: 0x40022010
        /// Status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// End of operation
            EOP: u1 = 0,
            /// Operation error
            OPERR: u1 = 0,
            _reserved2: u1 = 0,
            /// Programming error
            PROGERR: u1 = 0,
            /// Write protected error
            WRPERR: u1 = 0,
            /// Programming alignment error
            PGAERR: u1 = 0,
            /// Size error
            SIZERR: u1 = 0,
            /// Programming sequence error
            PGSERR: u1 = 0,
            /// Fast programming data miss error
            MISERR: u1 = 0,
            /// Fast programming error
            FASTERR: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Option and Engineering bits loading validity error
            OPTVERR: u1 = 0,
            /// BSY1
            BSY1: u1 = 0,
            /// BSY2
            BSY2: u1 = 0,
            /// Programming or erase configuration busy.
            CFGBSY: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40022014
        /// Flash control register
        pub const CR = @as(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1 = 0,
            /// Page erase
            PER: u1 = 0,
            /// Mass erase
            MER1: u1 = 0,
            /// Page number
            PNB: u10 = 0,
            /// BKER
            BKER: u1 = 0,
            _reserved14: u1 = 0,
            /// MER2
            MER2: u1 = 0,
            /// Start
            STRT: u1 = 0,
            /// Options modification start
            OPTSTRT: u1 = 0,
            /// Fast programming
            FSTPG: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// End of operation interrupt enable
            EOPIE: u1 = 0,
            /// Error interrupt enable
            ERRIE: u1 = 0,
            _reserved26: u1 = 0,
            /// Force the option byte loading
            OBL_LAUNCH: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            /// Options Lock
            OPTLOCK: u1 = 1,
            /// FLASH_CR Lock
            LOCK: u1 = 1,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40022018
        /// Flash ECC register
        pub const ECCR = @as(*volatile Mmio(32, packed struct {
            /// ECC fail address
            ADDR_ECC: u14 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            /// ECC fail for Corrected ECC Error or Double ECC Error in info block
            SYSF_ECC: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// ECC correction interrupt enable
            ECCIE: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            /// ECC correction
            ECCC: u1 = 0,
            /// ECC detection
            ECCD: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40022020
        /// Flash option register
        pub const OPTR = @as(*volatile Mmio(32, packed struct {
            /// Read protection level
            RDP: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            /// nRST_STOP
            nRST_STOP: u1 = 0,
            /// nRST_STDBY
            nRST_STDBY: u1 = 0,
            _reserved15: u1 = 0,
            /// Independent watchdog selection
            IDWG_SW: u1 = 0,
            /// Independent watchdog counter freeze in Stop mode
            IWDG_STOP: u1 = 0,
            /// Independent watchdog counter freeze in Standby mode
            IWDG_STDBY: u1 = 0,
            /// Window watchdog selection
            WWDG_SW: u1 = 0,
            /// nSWAP_BANK
            nSWAP_BANK: u1 = 0,
            /// DUAL_BANK
            DUAL_BANK: u1 = 0,
            /// SRAM parity check control
            RAM_PARITY_CHECK: u1 = 0,
            _reserved23: u1 = 0,
            /// nBOOT_SEL
            nBOOT_SEL: u1 = 0,
            /// Boot configuration
            nBOOT1: u1 = 0,
            /// nBOOT0 option bit
            nBOOT0: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 1,
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            _reserved31: u1 = 1,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x4002202c
        /// Flash WRP area A address register
        pub const WRP1AR = @as(*volatile Mmio(32, packed struct {
            /// WRP area A start offset
            WRP1A_STRT: u7 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// WRP area A end offset
            WRP1A_END: u7 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 1,
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            _reserved31: u1 = 1,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40022030
        /// Flash WRP area B address register
        pub const WRP1BR = @as(*volatile Mmio(32, packed struct {
            /// WRP area B start offset
            WRP1B_STRT: u7 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// WRP area B end offset
            WRP1B_END: u7 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 1,
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            _reserved31: u1 = 1,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x4002204c
        /// FLASH WRP2 area A address register
        pub const WRP2AR = @as(*volatile Mmio(32, packed struct {
            /// WRP2A_STRT
            WRP2A_STRT: u7 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// WRP2A_END
            WRP2A_END: u7 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40022050
        /// FLASH WRP2 area B address register
        pub const WRP2BR = @as(*volatile Mmio(32, packed struct {
            /// WRP2B_STRT
            WRP2B_STRT: u7 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// WRP2B_END
            WRP2B_END: u7 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// HSI16 clock enable
            HSION: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 1)),
            /// HSI16 always enable for peripheral kernels
            HSIKERON: rt.rcc.OscillatorEnableWhenStopped = fromInt(rt.rcc.OscillatorEnableWhenStopped, @as(u1, 0)),
            /// HSI16 clock ready flag
            HSIRDY: rt.rcc.OscillatorReadyFlag = fromInt(rt.rcc.OscillatorReadyFlag, @as(u1, 1)),
            /// HSI16 clock division factor
            HSIDIV: rt.rcc.HSIDIV = fromInt(rt.rcc.HSIDIV, @as(u3, 0)),
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// HSE clock enable
            HSEON: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// HSE clock ready flag
            HSERDY: rt.rcc.OscillatorReadyFlag = fromInt(rt.rcc.OscillatorReadyFlag, @as(u1, 0)),
            /// HSE crystal oscillator bypass
            HSEBYP: rt.rcc.OscillatorBypass = fromInt(rt.rcc.OscillatorBypass, @as(u1, 0)),
            /// Clock security system enable
            CSSON: rt.rcc.CssEnable = fromInt(rt.rcc.CssEnable, @as(u1, 0)),
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// PLL enable
            PLLON: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// PLL clock ready flag
            PLLRDY: rt.rcc.OscillatorReadyFlag = fromInt(rt.rcc.OscillatorReadyFlag, @as(u1, 0)),
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40021004
        /// Internal clock sources calibration register
        pub const ICSCR = @as(*volatile Mmio(32, packed struct {
            /// HSI16 clock calibration
            HSICAL: u8 = 0,
            /// HSI16 clock trimming
            HSITRIM: u7 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 1,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40021008
        /// Clock configuration register
        pub const CFGR = @as(*volatile Mmio(32, packed struct {
            /// System clock switch
            SW: rt.rcc.SystemClockSource = fromInt(rt.rcc.SystemClockSource, @as(u3, 0)),
            /// System clock switch status
            SWS: rt.rcc.SystemClockSource = fromInt(rt.rcc.SystemClockSource, @as(u3, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// AHB prescaler
            HPRE: rt.rcc.AHBPrescale = fromInt(rt.rcc.AHBPrescale, @as(u4, 0)),
            /// APB prescaler
            PPRE: rt.rcc.APBPrescale = fromInt(rt.rcc.APBPrescale, @as(u3, 0)),
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Microcontroller clock output
            MCOSEL: rt.rcc.MCOSource = fromInt(rt.rcc.MCOSource, @as(u4, 0)),
            /// Microcontroller clock output prescaler
            MCOPRE: rt.rcc.MCOPrescale = fromInt(rt.rcc.MCOPrescale, @as(u4, 0)),
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4002100c
        /// PLL configuration register
        pub const PLLCFGR = @as(*volatile Mmio(32, packed struct {
            /// PLL input clock source
            PLLSRC: rt.rcc.PLLSource = fromInt(rt.rcc.PLLSource, @as(u2, 0)),
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            /// Division factor M of the PLL input clock divider
            PLLM: rt.rcc.PLLMDivisor = fromInt(rt.rcc.PLLMDivisor, @as(u3, 0)),
            _reserved7: u1 = 0,
            /// PLL frequency multiplication factor N
            PLLN: rt.rcc.PLLNMultiplier = fromInt(rt.rcc.PLLNMultiplier, @as(u8, 16)),
            /// PLLPCLK clock output enable
            PLLPEN: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// PLL VCO division factor P for PLLPCLK clock output
            PLLP: rt.rcc.PLLPDivisor = fromInt(rt.rcc.PLLPDivisor, @as(u5, 0)),
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            /// PLLRCLK clock output enable
            PLLREN: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// PLL VCO division factor R for PLLRCLK clock output
            PLLR: rt.rcc.PLLRDivisor = fromInt(rt.rcc.PLLRDivisor, @as(u3, 0)),
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40021018
        /// Clock interrupt enable register
        pub const CIER = @as(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt enable
            LSIRDYIE: rt.InterruptEnable = fromInt(rt.InterruptEnable, @as(u1, 0)),
            /// LSE ready interrupt enable
            LSERDYIE: rt.InterruptEnable = fromInt(rt.InterruptEnable, @as(u1, 0)),
            _reserved2: u1 = 0,
            /// HSI ready interrupt enable
            HSIRDYIE: rt.InterruptEnable = fromInt(rt.InterruptEnable, @as(u1, 0)),
            /// HSE ready interrupt enable
            HSERDYIE: rt.InterruptEnable = fromInt(rt.InterruptEnable, @as(u1, 0)),
            /// PLL ready interrupt enable
            PLLRDYIE: rt.InterruptEnable = fromInt(rt.InterruptEnable, @as(u1, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4002101c
        /// Clock interrupt flag register
        pub const CIFR = @as(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            /// LSE ready interrupt flag
            LSERDYF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            _reserved2: u1 = 0,
            /// HSI ready interrupt flag
            HSIRDYF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            /// HSE ready interrupt flag
            HSERDYF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            /// PLL ready interrupt flag
            PLLRDYF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Clock security system interrupt flag
            CSSF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            /// LSE Clock security system interrupt flag
            LSECSSF: rt.InterruptFlag = fromInt(rt.InterruptFlag, @as(u1, 0)),
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40021020
        /// Clock interrupt clear register
        pub const CICR = @as(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt clear
            LSIRDYC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            /// LSE ready interrupt clear
            LSERDYC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            _reserved2: u1 = 0,
            /// HSI ready interrupt clear
            HSIRDYC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            /// HSE ready interrupt clear
            HSERDYC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            /// PLL ready interrupt clear
            PLLRDYC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Clock security system interrupt clear
            CSSC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            /// LSE Clock security system interrupt clear
            LSECSSC: rt.InterruptClearFlag = fromInt(rt.InterruptClearFlag, @as(u1, 0)),
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40021024
        /// I/O port reset register
        pub const IOPRSTR = @as(*volatile Mmio(32, packed struct {
            /// GPIOARST
            GPIOARST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// GPIOBRST
            GPIOBRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// GPIOCRST
            GPIOCRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// GPIODRST
            GPIODRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved4: u1 = 0,
            /// GPIOFRST
            GPIOFRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40021028
        /// AHB peripheral reset register
        pub const AHBRSTR = @as(*volatile Mmio(32, packed struct {
            /// DMA1 reset
            DMA1RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// FLITF reset
            FLASHRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            /// CRC reset
            CRCRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));

        /// address: 0x4002102c
        /// APB peripheral reset register 1
        pub const APBRSTR1 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            /// TIM3 timer reset
            TIM3RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// SPI2 reset
            SPI2RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            /// USART2 reset
            USART2RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            /// I2C1 reset
            I2C1RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// I2C2 reset
            I2C2RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            /// Debug support reset
            DBGRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// Power interface reset
            PWRRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40021030
        /// APB peripheral reset register 2
        pub const APBRSTR2 = @as(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF reset
            SYSCFGRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            /// TIM1 timer reset
            TIM1RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// SPI1 reset
            SPI1RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved13: u1 = 0,
            /// USART1 reset
            USART1RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// TIM14 timer reset
            TIM14RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved16: u1 = 0,
            /// TIM16 timer reset
            TIM16RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            /// TIM17 timer reset
            TIM17RST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved19: u1 = 0,
            /// ADC reset
            ADCRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40021034
        /// GPIO clock enable register
        pub const IOPENR = @as(*volatile Mmio(32, packed struct {
            /// I/O port A clock enable
            GPIOAEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// I/O port B clock enable
            GPIOBEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// I/O port C clock enable
            GPIOCEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// I/O port D clock enable
            GPIODEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved4: u1 = 0,
            /// I/O port F clock enable
            GPIOFEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x40021038
        /// AHB peripheral clock enable register
        pub const AHBENR = @as(*volatile Mmio(32, packed struct {
            /// DMA1 clock enable
            DMA1EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Flash memory interface clock enable
            FLASHEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 1)),
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            /// CRC clock enable
            CRCEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x38));

        /// address: 0x4002103c
        /// APB peripheral clock enable register 1
        pub const APBENR1 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            /// TIM3 timer clock enable
            TIM3EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            /// RTC APB clock enable
            RTCAPBEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// WWDG clock enable
            WWDGEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// SPI2 clock enable
            SPI2EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            /// USART2 clock enable
            USART2EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            /// I2C1 clock enable
            I2C1EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// I2C2 clock enable
            I2C2EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            /// Debug support clock enable
            DBGEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// Power interface clock enable
            PWREN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40021040
        /// APB peripheral clock enable register 2
        pub const APBENR2 = @as(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF clock enable
            SYSCFGEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            /// TIM1 timer clock enable
            TIM1EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// SPI1 clock enable
            SPI1EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved13: u1 = 0,
            /// USART1 clock enable
            USART1EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// TIM14 timer clock enable
            TIM14EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved16: u1 = 0,
            /// TIM16 timer clock enable
            TIM16EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// TIM16 timer clock enable
            TIM17EN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved19: u1 = 0,
            /// ADC clock enable
            ADCEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x40021044
        /// GPIO in Sleep mode clock enable register
        pub const IOPSMENR = @as(*volatile Mmio(32, packed struct {
            /// I/O port A clock enable during Sleep mode
            GPIOASMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// I/O port B clock enable during Sleep mode
            GPIOBSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// I/O port C clock enable during Sleep mode
            GPIOCSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// I/O port D clock enable during Sleep mode
            GPIODSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved4: u1 = 1,
            /// I/O port F clock enable during Sleep mode
            GPIOFSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40021048
        /// AHB peripheral clock enable in Sleep mode register
        pub const AHBSMENR = @as(*volatile Mmio(32, packed struct {
            /// DMA1 clock enable during Sleep mode
            DMA1SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved1: u1 = 1,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Flash memory interface clock enable during Sleep mode
            FLASHSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// SRAM clock enable during Sleep mode
            SRAMSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            /// CRC clock enable during Sleep mode
            CRCSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 1,
            _reserved17: u1 = 0,
            _reserved18: u1 = 1,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4002104c
        /// APB peripheral clock enable in Sleep mode register 1
        pub const APBSMENR1 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 1,
            /// TIM3 timer clock enable during Sleep mode
            TIM3SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved2: u1 = 1,
            _reserved3: u1 = 0,
            _reserved4: u1 = 1,
            _reserved5: u1 = 1,
            _reserved6: u1 = 0,
            _reserved7: u1 = 1,
            _reserved8: u1 = 1,
            _reserved9: u1 = 1,
            /// RTC APB clock enable during Sleep mode
            RTCAPBSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// WWDG clock enable during Sleep mode
            WWDGSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved12: u1 = 1,
            _reserved13: u1 = 1,
            /// SPI2 clock enable during Sleep mode
            SPI2SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved15: u1 = 1,
            _reserved16: u1 = 1,
            /// USART2 clock enable during Sleep mode
            USART2SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved18: u1 = 1,
            _reserved19: u1 = 1,
            _reserved20: u1 = 1,
            /// I2C1 clock enable during Sleep mode
            I2C1SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// I2C2 clock enable during Sleep mode
            I2C2SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved23: u1 = 1,
            _reserved24: u1 = 1,
            _reserved25: u1 = 1,
            _reserved26: u1 = 1,
            /// Debug support clock enable during Sleep mode
            DBGSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// Power interface clock enable during Sleep mode
            PWRSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            _reserved31: u1 = 1,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40021050
        /// APB peripheral clock enable in Sleep mode register 2
        pub const APBSMENR2 = @as(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF clock enable during Sleep mode
            SYSCFGSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            /// TIM1 timer clock enable during Sleep mode
            TIM1SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// SPI1 clock enable during Sleep mode
            SPI1SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved13: u1 = 0,
            /// USART1 clock enable during Sleep mode
            USART1SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// TIM14 timer clock enable during Sleep mode
            TIM14SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved16: u1 = 1,
            /// TIM16 timer clock enable during Sleep mode
            TIM16SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            /// TIM16 timer clock enable during Sleep mode
            TIM17SMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved19: u1 = 0,
            /// ADC clock enable during Sleep mode
            ADCSMEN: rt.rcc.ClockEnableWhenSleeping = fromInt(rt.rcc.ClockEnableWhenSleeping, @as(u1, 1)),
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));

        /// address: 0x40021054
        /// Peripherals independent clock configuration register
        pub const CCIPR = @as(*volatile Mmio(32, packed struct {
            /// USART clock source selection
            USARTSEL: rt.rcc.UsartClockSource = fromInt(rt.rcc.UsartClockSource, @as(u2, 0)),
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            /// I2C clock source selection
            I2CSEL: rt.rcc.I2CClockSource = fromInt(rt.rcc.I2CClockSource, @as(u2, 0)),
            /// I2S clock source selection
            I2SSEL: rt.rcc.I2SClockSource = fromInt(rt.rcc.I2SClockSource, @as(u2, 0)),
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            /// ADCs clock source selection
            ADCSEL: rt.rcc.AdcClockSource = fromInt(rt.rcc.AdcClockSource, @as(u2, 0)),
        }), @ptrFromInt(base_address + 0x54));

        /// address: 0x4002105c
        /// RTC domain control register
        pub const BDCR = @as(*volatile Mmio(32, packed struct {
            /// LSE oscillator enable
            LSEON: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// LSE oscillator ready
            LSERDY: rt.rcc.OscillatorReadyFlag = fromInt(rt.rcc.OscillatorReadyFlag, @as(u1, 0)),
            /// LSE oscillator bypass
            LSEBYP: rt.rcc.OscillatorBypass = fromInt(rt.rcc.OscillatorBypass, @as(u1, 0)),
            /// LSE oscillator drive capability
            LSEDRV: rt.rcc.LSEDRV = fromInt(rt.rcc.LSEDRV, @as(u2, 0)),
            /// CSS on LSE enable
            LSECSSON: rt.rcc.CssEnable = fromInt(rt.rcc.CssEnable, @as(u1, 0)),
            /// CSS on LSE failure Detection
            LSECSSD: rt.rcc.LSECSSD = fromInt(rt.rcc.LSECSSD, @as(u1, 0)),
            _reserved7: u1 = 0,
            /// RTC clock source selection
            RTCSEL: rt.rcc.RtcClockSource = fromInt(rt.rcc.RtcClockSource, @as(u2, 0)),
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// RTC clock enable
            RTCEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// RTC domain software reset
            BDRST: rt.PeripheralReset = fromInt(rt.PeripheralReset, @as(u1, 0)),
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Low-speed clock output (LSCO) enable
            LSCOEN: rt.rcc.ClockEnable = fromInt(rt.rcc.ClockEnable, @as(u1, 0)),
            /// Low-speed clock output selection
            LSCOSEL: rt.rcc.LSCOSource = fromInt(rt.rcc.LSCOSource, @as(u1, 0)),
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x5c));

        /// address: 0x40021060
        /// Control/status register
        pub const CSR = @as(*volatile Mmio(32, packed struct {
            /// LSI oscillator enable
            LSION: rt.rcc.OscillatorEnable = fromInt(rt.rcc.OscillatorEnable, @as(u1, 0)),
            /// LSI oscillator ready
            LSIRDY: rt.rcc.OscillatorReadyFlag = fromInt(rt.rcc.OscillatorReadyFlag, @as(u1, 0)),
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            /// Remove reset flags
            RMVF: rt.rcc.RMVF = fromInt(rt.rcc.RMVF, @as(u1, 0)),
            _reserved24: u1 = 0,
            /// Option byte loader reset flag
            OBLRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// Pin reset flag
            PINRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// BOR or POR/PDR flag
            PWRRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// Software reset flag
            SFTRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// Independent window watchdog reset flag
            IWDGRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// Window watchdog reset flag
            WWDGRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
            /// Low-power reset flag
            LPWRRSTF: rt.rcc.ResetFlag = fromInt(rt.rcc.ResetFlag, @as(u1, 0)),
        }), @ptrFromInt(base_address + 0x60));
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// Power control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Low-power mode selection
            LPMS: u3 = 0,
            /// Flash memory powered down during Stop mode
            FPD_STOP: u1 = 1,
            /// Flash memory powered down during Low-power run mode
            FPD_LPRUN: u1 = 0,
            /// Flash memory powered down during Low-power sleep mode
            FPD_LPSLP: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Disable backup domain write protection
            DBP: u1 = 0,
            /// Voltage scaling range selection
            VOS: u2 = 1,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// Low-power run
            LPR: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40007004
        /// Power control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            /// USV
            USV: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40007008
        /// Power control register 3
        pub const CR3 = @as(*volatile Mmio(32, packed struct {
            /// Enable Wakeup pin WKUP1
            EWUP1: u1 = 0,
            /// Enable Wakeup pin WKUP2
            EWUP2: u1 = 0,
            /// Enable Wakeup pin WKUP3
            EWUP3: u1 = 0,
            /// Enable Wakeup pin WKUP4
            EWUP4: u1 = 0,
            /// Enable WKUP5 wakeup pin
            EWUP5: u1 = 0,
            /// Enable WKUP6 wakeup pin
            EWUP6: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            /// Apply pull-up and pull-down configuration
            APC: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Enable internal wakeup line
            EIWUL: u1 = 1,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000700c
        /// Power control register 4
        pub const CR4 = @as(*volatile Mmio(32, packed struct {
            /// Wakeup pin WKUP1 polarity
            WP1: u1 = 0,
            /// Wakeup pin WKUP2 polarity
            WP2: u1 = 0,
            /// Wakeup pin WKUP3 polarity
            WP3: u1 = 0,
            /// Wakeup pin WKUP4 polarity
            WP4: u1 = 0,
            /// Wakeup pin WKUP5 polarity
            WP5: u1 = 0,
            /// WKUP6 wakeup pin polarity
            WP6: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// VBAT battery charging enable
            VBE: u1 = 0,
            /// VBAT battery charging resistor selection
            VBRS: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40007010
        /// Power status register 1
        pub const SR1 = @as(*volatile Mmio(32, packed struct {
            /// Wakeup flag 1
            WUF1: u1 = 0,
            /// Wakeup flag 2
            WUF2: u1 = 0,
            /// Wakeup flag 3
            WUF3: u1 = 0,
            /// Wakeup flag 4
            WUF4: u1 = 0,
            /// Wakeup flag 5
            WUF5: u1 = 0,
            /// Wakeup flag 6
            WUF6: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Standby flag
            SBF: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Wakeup flag internal
            WUFI: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40007014
        /// Power status register 2
        pub const SR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Flash ready flag
            FLASH_RDY: u1 = 0,
            /// Low-power regulator started
            REGLPS: u1 = 0,
            /// Low-power regulator flag
            REGLPF: u1 = 0,
            /// Voltage scaling flag
            VOSF: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40007018
        /// Power status clear register
        pub const SCR = @as(*volatile Mmio(32, packed struct {
            /// Clear wakeup flag 1
            CWUF1: u1 = 0,
            /// Clear wakeup flag 2
            CWUF2: u1 = 0,
            /// Clear wakeup flag 3
            CWUF3: u1 = 0,
            /// Clear wakeup flag 4
            CWUF4: u1 = 0,
            /// Clear wakeup flag 5
            CWUF5: u1 = 0,
            /// Clear wakeup flag 6
            CWUF6: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Clear standby flag
            CSBF: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40007020
        /// Power Port A pull-up control register
        pub const PUCRA = @as(*volatile Mmio(32, packed struct {
            /// Port A pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU13: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU14: u1 = 0,
            /// Port A pull-up bit y (y=0..15)
            PU15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40007024
        /// Power Port A pull-down control register
        pub const PDCRA = @as(*volatile Mmio(32, packed struct {
            /// Port A pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD13: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD14: u1 = 0,
            /// Port A pull-down bit y (y=0..15)
            PD15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40007028
        /// Power Port B pull-up control register
        pub const PUCRB = @as(*volatile Mmio(32, packed struct {
            /// Port B pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU13: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU14: u1 = 0,
            /// Port B pull-up bit y (y=0..15)
            PU15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000702c
        /// Power Port B pull-down control register
        pub const PDCRB = @as(*volatile Mmio(32, packed struct {
            /// Port B pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD13: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD14: u1 = 0,
            /// Port B pull-down bit y (y=0..15)
            PD15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40007030
        /// Power Port C pull-up control register
        pub const PUCRC = @as(*volatile Mmio(32, packed struct {
            /// Port C pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU13: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU14: u1 = 0,
            /// Port C pull-up bit y (y=0..15)
            PU15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40007034
        /// Power Port C pull-down control register
        pub const PDCRC = @as(*volatile Mmio(32, packed struct {
            /// Port C pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD13: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD14: u1 = 0,
            /// Port C pull-down bit y (y=0..15)
            PD15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x40007038
        /// Power Port D pull-up control register
        pub const PUCRD = @as(*volatile Mmio(32, packed struct {
            /// Port D pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU13: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU14: u1 = 0,
            /// Port D pull-up bit y (y=0..15)
            PU15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x38));

        /// address: 0x4000703c
        /// Power Port D pull-down control register
        pub const PDCRD = @as(*volatile Mmio(32, packed struct {
            /// Port D pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD13: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD14: u1 = 0,
            /// Port D pull-down bit y (y=0..15)
            PD15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40007040
        /// Power Port E pull-UP control register
        pub const PUCRE = @as(*volatile Mmio(32, packed struct {
            /// Port E pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU13: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU14: u1 = 0,
            /// Port E pull-up bit y (y=0..15)
            PU15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x40007044
        /// Power Port E pull-down control register
        pub const PDCRE = @as(*volatile Mmio(32, packed struct {
            /// Port E pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD13: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD14: u1 = 0,
            /// Port E pull-down bit y (y=0..15)
            PD15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40007048
        /// Power Port F pull-up control register
        pub const PUCRF = @as(*volatile Mmio(32, packed struct {
            /// Port F pull-up bit y (y=0..15)
            PU0: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU1: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU2: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU3: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU4: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU5: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU6: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU7: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU8: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU9: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU10: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU11: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU12: u1 = 0,
            /// Port F pull-up bit y (y=0..15)
            PU13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4000704c
        /// Power Port F pull-down control register
        pub const PDCRF = @as(*volatile Mmio(32, packed struct {
            /// Port F pull-down bit y (y=0..15)
            PD0: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD1: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD2: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD3: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD4: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD5: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD6: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD7: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD8: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD9: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD10: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD11: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD12: u1 = 0,
            /// Port F pull-down bit y (y=0..15)
            PD13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));
    };

    /// DMA controller
    pub const DMA = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// DMA interrupt status register
        pub const ISR = @as(*volatile Mmio(32, packed struct {
            /// global interrupt flag for channel 1
            GIF1: u1 = 0,
            /// transfer complete (TC) flag for channel 1
            TCIF1: u1 = 0,
            /// half transfer (HT) flag for channel 1
            HTIF1: u1 = 0,
            /// transfer error (TE) flag for channel 1
            TEIF1: u1 = 0,
            /// global interrupt flag for channel 2
            GIF2: u1 = 0,
            /// transfer complete (TC) flag for channel 2
            TCIF2: u1 = 0,
            /// half transfer (HT) flag for channel 2
            HTIF2: u1 = 0,
            /// transfer error (TE) flag for channel 2
            TEIF2: u1 = 0,
            /// global interrupt flag for channel 3
            GIF3: u1 = 0,
            /// transfer complete (TC) flag for channel 3
            TCIF3: u1 = 0,
            /// half transfer (HT) flag for channel 3
            HTIF3: u1 = 0,
            /// transfer error (TE) flag for channel 3
            TEIF3: u1 = 0,
            /// global interrupt flag for channel 4
            GIF4: u1 = 0,
            /// transfer complete (TC) flag for channel 4
            TCIF4: u1 = 0,
            /// half transfer (HT) flag for channel 4
            HTIF4: u1 = 0,
            /// transfer error (TE) flag for channel 4
            TEIF4: u1 = 0,
            /// global interrupt flag for channel 5
            GIF5: u1 = 0,
            /// transfer complete (TC) flag for channel 5
            TCIF5: u1 = 0,
            /// half transfer (HT) flag for channel 5
            HTIF5: u1 = 0,
            /// transfer error (TE) flag for channel 5
            TEIF5: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40020004
        /// DMA interrupt flag clear register
        pub const IFCR = @as(*volatile Mmio(32, packed struct {
            /// global interrupt flag clear for channel 1
            CGIF1: u1 = 0,
            /// transfer complete flag clear for channel 1
            CTCIF1: u1 = 0,
            /// half transfer flag clear for channel 1
            CHTIF1: u1 = 0,
            /// transfer error flag clear for channel 1
            CTEIF1: u1 = 0,
            /// global interrupt flag clear for channel 2
            CGIF2: u1 = 0,
            /// transfer complete flag clear for channel 2
            CTCIF2: u1 = 0,
            /// half transfer flag clear for channel 2
            CHTIF2: u1 = 0,
            /// transfer error flag clear for channel 2
            CTEIF2: u1 = 0,
            /// global interrupt flag clear for channel 3
            CGIF3: u1 = 0,
            /// transfer complete flag clear for channel 3
            CTCIF3: u1 = 0,
            /// half transfer flag clear for channel 3
            CHTIF3: u1 = 0,
            /// transfer error flag clear for channel 3
            CTEIF3: u1 = 0,
            /// global interrupt flag clear for channel 4
            CGIF4: u1 = 0,
            /// transfer complete flag clear for channel 4
            CTCIF4: u1 = 0,
            /// half transfer flag clear for channel 4
            CHTIF4: u1 = 0,
            /// transfer error flag clear for channel 4
            CTEIF4: u1 = 0,
            /// global interrupt flag clear for channel 5
            CGIF5: u1 = 0,
            /// transfer complete flag clear for channel 5
            CTCIF5: u1 = 0,
            /// half transfer flag clear for channel 5
            CHTIF5: u1 = 0,
            /// transfer error flag clear for channel 5
            CTEIF5: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40020008
        /// DMA channel 1 configuration register
        pub const CCR1 = @as(*volatile Mmio(32, rt.dma.CCR), @ptrFromInt(base_address + 0x8));

        /// address: 0x4002000c
        /// DMA channel 1 number of data register
        pub const CNDTR1 = @as(*volatile Mmio(32, rt.dma.CNDTR), @ptrFromInt(base_address + 0xc));

        /// address: 0x40020010
        /// DMA channel 1 peripheral address register
        pub const CPAR1 = @as(*volatile Mmio(32, rt.dma.CPAR), @ptrFromInt(base_address + 0x10));

        /// address: 0x40020014
        /// DMA channel 1 memory address register
        pub const CMAR1 = @as(*volatile Mmio(32, rt.dma.CMAR), @ptrFromInt(base_address + 0x14));

        /// address: 0x4002001c
        /// DMA channel 2 configuration register
        pub const CCR2 = @as(*volatile Mmio(32, rt.dma.CCR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40020020
        /// DMA channel 2 number of data register
        pub const CNDTR2 = @as(*volatile Mmio(32, rt.dma.CNDTR), @ptrFromInt(base_address + 0x20));

        /// address: 0x40020024
        /// DMA channel 2 peripheral address register
        pub const CPAR2 = @as(*volatile Mmio(32, rt.dma.CPAR), @ptrFromInt(base_address + 0x24));

        /// address: 0x40020028
        /// DMA channel 2 memory address register
        pub const CMAR2 = @as(*volatile Mmio(32, rt.dma.CMAR), @ptrFromInt(base_address + 0x28));

        /// address: 0x40020030
        /// DMA channel 3 configuration register
        pub const CCR3 = @as(*volatile Mmio(32, rt.dma.CCR), @ptrFromInt(base_address + 0x30));

        /// address: 0x40020034
        /// DMA channel 3 configuration register
        pub const CNDTR3 = @as(*volatile Mmio(32, rt.dma.CNDTR), @ptrFromInt(base_address + 0x34));

        /// address: 0x40020038
        /// DMA channel 3 peripheral address register
        pub const CPAR3 = @as(*volatile Mmio(32, rt.dma.CPAR), @ptrFromInt(base_address + 0x38));

        /// address: 0x4002003c
        /// DMA channel 3 memory address register
        pub const CMAR3 = @as(*volatile Mmio(32, rt.dma.CMAR), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40020044
        /// DMA channel 4 configuration register
        pub const CCR4 = @as(*volatile Mmio(32, rt.dma.CCR), @ptrFromInt(base_address + 0x44));

        /// address: 0x40020048
        /// DMA channel 4 configuration register
        pub const CNDTR4 = @as(*volatile Mmio(32, rt.dma.CNDTR), @ptrFromInt(base_address + 0x48));

        /// address: 0x4002004c
        /// DMA channel 4 peripheral address register
        pub const CPAR4 = @as(*volatile Mmio(32, rt.dma.CPAR), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40020050
        /// DMA channel 4 memory address register
        pub const CMAR4 = @as(*volatile Mmio(32, rt.dma.CMAR), @ptrFromInt(base_address + 0x50));

        /// address: 0x40020058
        /// DMA channel 5 configuration register
        pub const CCR5 = @as(*volatile Mmio(32, rt.dma.CCR), @ptrFromInt(base_address + 0x58));

        /// address: 0x4002005c
        /// DMA channel 5 configuration register
        pub const CNDTR5 = @as(*volatile Mmio(32, rt.dma.CNDTR), @ptrFromInt(base_address + 0x5c));

        /// address: 0x40020060
        /// DMA channel 5 peripheral address register
        pub const CPAR5 = @as(*volatile Mmio(32, rt.dma.CPAR), @ptrFromInt(base_address + 0x60));

        /// address: 0x40020064
        /// DMA channel 5 memory address register
        pub const CMAR5 = @as(*volatile Mmio(32, rt.dma.CMAR), @ptrFromInt(base_address + 0x64));
    };

    /// DMAMUX
    pub const DMAMUX = struct {
        pub const base_address = 0x40020800;

        /// address: 0x40020800
        /// DMAMux - DMA request line multiplexer channel x control register
        pub const C0CR = @as(*volatile Mmio(32, rt.dma.mux.CR), @ptrFromInt(base_address + 0x0));

        /// address: 0x40020804
        /// DMAMux - DMA request line multiplexer channel x control register
        pub const C1CR = @as(*volatile Mmio(32, rt.dma.mux.CR), @ptrFromInt(base_address + 0x4));

        /// address: 0x40020808
        /// DMAMux - DMA request line multiplexer channel x control register
        pub const C2CR = @as(*volatile Mmio(32, rt.dma.mux.CR), @ptrFromInt(base_address + 0x8));

        /// address: 0x4002080c
        /// DMAMux - DMA request line multiplexer channel x control register
        pub const C3CR = @as(*volatile Mmio(32, rt.dma.mux.CR), @ptrFromInt(base_address + 0xc));

        /// address: 0x40020810
        /// DMAMux - DMA request line multiplexer channel x control register
        pub const C4CR = @as(*volatile Mmio(32, rt.dma.mux.CR), @ptrFromInt(base_address + 0x10));

        /// address: 0x40020900
        /// DMAMux - DMA request generator channel x control register
        pub const RG0CR = @as(*volatile Mmio(32, rt.dma.mux.RGCR), @ptrFromInt(base_address + 0x100));

        /// address: 0x40020904
        /// DMAMux - DMA request generator channel x control register
        pub const RG1CR = @as(*volatile Mmio(32, rt.dma.mux.RGCR), @ptrFromInt(base_address + 0x104));

        /// address: 0x40020908
        /// DMAMux - DMA request generator channel x control register
        pub const RG2CR = @as(*volatile Mmio(32, rt.dma.mux.RGCR), @ptrFromInt(base_address + 0x108));

        /// address: 0x4002090c
        /// DMAMux - DMA request generator channel x control register
        pub const RG3CR = @as(*volatile Mmio(32, rt.dma.mux.RGCR), @ptrFromInt(base_address + 0x10c));

        /// address: 0x40020940
        /// DMAMux - DMA request generator status register
        pub const RGSR = @as(*volatile Mmio(32, rt.dma.mux.RGSR), @ptrFromInt(base_address + 0x140));

        /// address: 0x40020944
        /// DMAMux - DMA request generator clear flag register
        pub const RGCFR = @as(*volatile Mmio(32, rt.dma.mux.RGCFR), @ptrFromInt(base_address + 0x144));
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// GPIO port mode register
        pub const MODER = @as(*volatile Mmio(32, rt.gpio.MODER), @ptrFromInt(base_address + 0x0));

        /// address: 0x50000004
        /// GPIO port output type register
        pub const OTYPER = @as(*volatile Mmio(32, rt.gpio.OTYPER), @ptrFromInt(base_address + 0x4));

        /// address: 0x50000008
        /// GPIO port output speed register
        pub const OSPEEDR = @as(*volatile Mmio(32, rt.gpio.OSPEEDR), @ptrFromInt(base_address + 0x8));

        /// address: 0x5000000c
        /// GPIO port pull-up/pull-down register
        pub const PUPDR = @as(*volatile Mmio(32, rt.gpio.PUPDR), @ptrFromInt(base_address + 0xc));

        /// address: 0x50000010
        /// GPIO port input data register
        pub const IDR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x10));

        /// address: 0x50000014
        /// GPIO port output data register
        pub const ODR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x14));

        /// address: 0x50000018
        /// GPIO port bit set/reset register
        pub const BSRR = @as(*volatile Mmio(32, rt.gpio.BSRR), @ptrFromInt(base_address + 0x18));

        /// address: 0x5000001c
        /// GPIO port configuration lock register
        pub const LCKR = @as(*volatile Mmio(32, rt.gpio.LCKR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x50000020
        /// GPIO alternate function low register
        pub const AFRL = @as(*volatile Mmio(32, rt.gpio.GPIOA_AFRL), @ptrFromInt(base_address + 0x20));

        /// address: 0x50000024
        /// GPIO alternate function high register
        pub const AFRH = @as(*volatile Mmio(32, rt.gpio.GPIOA_AFRH), @ptrFromInt(base_address + 0x24));

        /// address: 0x50000028
        /// port bit reset register
        pub const BRR = @as(*volatile Mmio(32, rt.gpio.BRR), @ptrFromInt(base_address + 0x28));
    };

    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// GPIO port mode register
        pub const MODER = @as(*volatile Mmio(32, rt.gpio.MODER), @ptrFromInt(base_address + 0x0));

        /// address: 0x50000404
        /// GPIO port output type register
        pub const OTYPER = @as(*volatile Mmio(32, rt.gpio.OTYPER), @ptrFromInt(base_address + 0x4));

        /// address: 0x50000408
        /// GPIO port output speed register
        pub const OSPEEDR = @as(*volatile Mmio(32, rt.gpio.OSPEEDR), @ptrFromInt(base_address + 0x8));

        /// address: 0x5000040c
        /// GPIO port pull-up/pull-down register
        pub const PUPDR = @as(*volatile Mmio(32, rt.gpio.PUPDR), @ptrFromInt(base_address + 0xc));

        /// address: 0x50000410
        /// GPIO port input data register
        pub const IDR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x10));

        /// address: 0x50000414
        /// GPIO port output data register
        pub const ODR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x14));

        /// address: 0x50000418
        /// GPIO port bit set/reset register
        pub const BSRR = @as(*volatile Mmio(32, rt.gpio.BSRR), @ptrFromInt(base_address + 0x18));

        /// address: 0x5000041c
        /// GPIO port configuration lock register
        pub const LCKR = @as(*volatile Mmio(32, rt.gpio.LCKR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x50000420
        /// GPIO alternate function low register
        pub const AFRL = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRL), @ptrFromInt(base_address + 0x20));

        /// address: 0x50000424
        /// GPIO alternate function high register
        pub const AFRH = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRH), @ptrFromInt(base_address + 0x24));

        /// address: 0x50000428
        /// port bit reset register
        pub const BRR = @as(*volatile Mmio(32, rt.gpio.BRR), @ptrFromInt(base_address + 0x28));
    };
    pub const GPIOC = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// GPIO port mode register
        pub const MODER = @as(*volatile Mmio(32, rt.gpio.MODER), @ptrFromInt(base_address + 0x0));

        /// address: 0x50000804
        /// GPIO port output type register
        pub const OTYPER = @as(*volatile Mmio(32, rt.gpio.OTYPER), @ptrFromInt(base_address + 0x4));

        /// address: 0x50000808
        /// GPIO port output speed register
        pub const OSPEEDR = @as(*volatile Mmio(32, rt.gpio.OSPEEDR), @ptrFromInt(base_address + 0x8));

        /// address: 0x5000080c
        /// GPIO port pull-up/pull-down register
        pub const PUPDR = @as(*volatile Mmio(32, rt.gpio.PUPDR), @ptrFromInt(base_address + 0xc));

        /// address: 0x50000810
        /// GPIO port input data register
        pub const IDR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x10));

        /// address: 0x50000814
        /// GPIO port output data register
        pub const ODR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x14));

        /// address: 0x50000818
        /// GPIO port bit set/reset register
        pub const BSRR = @as(*volatile Mmio(32, rt.gpio.BSRR), @ptrFromInt(base_address + 0x18));

        /// address: 0x5000081c
        /// GPIO port configuration lock register
        pub const LCKR = @as(*volatile Mmio(32, rt.gpio.LCKR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x50000820
        /// GPIO alternate function low register
        pub const AFRL = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRL), @ptrFromInt(base_address + 0x20));

        /// address: 0x50000824
        /// GPIO alternate function high register
        pub const AFRH = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRH), @ptrFromInt(base_address + 0x24));

        /// address: 0x50000828
        /// port bit reset register
        pub const BRR = @as(*volatile Mmio(32, rt.gpio.BRR), @ptrFromInt(base_address + 0x28));
    };
    pub const GPIOD = struct {
        pub const base_address = 0x50000c00;

        /// address: 0x50000c00
        /// GPIO port mode register
        pub const MODER = @as(*volatile Mmio(32, rt.gpio.MODER), @ptrFromInt(base_address + 0x0));

        /// address: 0x50000c04
        /// GPIO port output type register
        pub const OTYPER = @as(*volatile Mmio(32, rt.gpio.OTYPER), @ptrFromInt(base_address + 0x4));

        /// address: 0x50000c08
        /// GPIO port output speed register
        pub const OSPEEDR = @as(*volatile Mmio(32, rt.gpio.OSPEEDR), @ptrFromInt(base_address + 0x8));

        /// address: 0x50000c0c
        /// GPIO port pull-up/pull-down register
        pub const PUPDR = @as(*volatile Mmio(32, rt.gpio.PUPDR), @ptrFromInt(base_address + 0xc));

        /// address: 0x50000c10
        /// GPIO port input data register
        pub const IDR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x10));

        /// address: 0x50000c14
        /// GPIO port output data register
        pub const ODR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x14));

        /// address: 0x50000c18
        /// GPIO port bit set/reset register
        pub const BSRR = @as(*volatile Mmio(32, rt.gpio.BSRR), @ptrFromInt(base_address + 0x18));

        /// address: 0x50000c1c
        /// GPIO port configuration lock register
        pub const LCKR = @as(*volatile Mmio(32, rt.gpio.LCKR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x50000c20
        /// GPIO alternate function low register
        pub const AFRL = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRL), @ptrFromInt(base_address + 0x20));

        /// address: 0x50000c24
        /// GPIO alternate function high register
        pub const AFRH = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRH), @ptrFromInt(base_address + 0x24));

        /// address: 0x50000c28
        /// port bit reset register
        pub const BRR = @as(*volatile Mmio(32, rt.gpio.BRR), @ptrFromInt(base_address + 0x28));
    };
    pub const GPIOF = struct {
        pub const base_address = 0x50001400;

        /// address: 0x50001400
        /// GPIO port mode register
        pub const MODER = @as(*volatile Mmio(32, rt.gpio.MODER), @ptrFromInt(base_address + 0x0));

        /// address: 0x50001404
        /// GPIO port output type register
        pub const OTYPER = @as(*volatile Mmio(32, rt.gpio.OTYPER), @ptrFromInt(base_address + 0x4));

        /// address: 0x50001408
        /// GPIO port output speed register
        pub const OSPEEDR = @as(*volatile Mmio(32, rt.gpio.OSPEEDR), @ptrFromInt(base_address + 0x8));

        /// address: 0x5000140c
        /// GPIO port pull-up/pull-down register
        pub const PUPDR = @as(*volatile Mmio(32, rt.gpio.PUPDR), @ptrFromInt(base_address + 0xc));

        /// address: 0x50001410
        /// GPIO port input data register
        pub const IDR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x10));

        /// address: 0x50001414
        /// GPIO port output data register
        pub const ODR = @as(*volatile Mmio(32, rt.gpio.DR), @ptrFromInt(base_address + 0x14));

        /// address: 0x50001418
        /// GPIO port bit set/reset register
        pub const BSRR = @as(*volatile Mmio(32, rt.gpio.BSRR), @ptrFromInt(base_address + 0x18));

        /// address: 0x5000141c
        /// GPIO port configuration lock register
        pub const LCKR = @as(*volatile Mmio(32, rt.gpio.LCKR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x50001420
        /// GPIO alternate function low register
        pub const AFRL = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRL), @ptrFromInt(base_address + 0x20));

        /// address: 0x50001424
        /// GPIO alternate function high register
        pub const AFRH = @as(*volatile Mmio(32, rt.gpio.GPIOF_AFRH), @ptrFromInt(base_address + 0x24));

        /// address: 0x50001428
        /// port bit reset register
        pub const BRR = @as(*volatile Mmio(32, rt.gpio.BRR), @ptrFromInt(base_address + 0x28));
    };

    /// Cyclic redundancy check calculation unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @as(*volatile u32, @ptrFromInt(base_address + 0x0));

        /// address: 0x40023004
        /// Independent data register
        pub const IDR = @as(*volatile u32, @ptrFromInt(base_address + 0x4));

        /// address: 0x40023008
        /// Control register
        pub const CR = @as(*volatile Mmio(32, packed struct {
            /// RESET bit
            RESET: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            /// Polynomial size
            POLYSIZE: u2 = 0,
            /// Reverse input data
            REV_IN: u2 = 0,
            /// Reverse output data
            REV_OUT: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x40023010
        /// Initial CRC value
        pub const INIT = @as(*volatile Mmio(32, packed struct {
            /// Programmable initial CRC value
            CRC_INIT: u32 = 4294967295,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40023014
        /// polynomial
        pub const POL = @as(*volatile u32, @ptrFromInt(base_address + 0x14));
    };

    /// External interrupt/event controller
    pub const EXTI = struct {
        pub const base_address = 0x40021800;

        /// address: 0x40021800
        /// EXTI rising trigger selection register
        pub const RTSR1 = @as(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration bit of Configurable Event line
            RT0: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT1: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT2: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT3: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT4: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT5: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT6: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT7: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT8: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT9: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT10: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT11: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT12: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT13: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT14: u1 = 0,
            /// Rising trigger event configuration bit of Configurable Event line
            RT15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40021804
        /// EXTI falling trigger selection register
        pub const FTSR1 = @as(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration bit of configurable line
            FT0: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT1: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT2: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT3: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT4: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT5: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT6: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT7: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT8: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT9: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT10: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT11: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT12: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT13: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT14: u1 = 0,
            /// Falling trigger event configuration bit of configurable line
            FT15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40021808
        /// EXTI software interrupt event register
        pub const SWIER1 = @as(*volatile Mmio(32, packed struct {
            /// Software rising edge event trigger on line
            SWI0: u1 = 0,
            /// Software rising edge event trigger on line
            SWI1: u1 = 0,
            /// Software rising edge event trigger on line
            SWI2: u1 = 0,
            /// Software rising edge event trigger on line
            SWI3: u1 = 0,
            /// Software rising edge event trigger on line
            SWI4: u1 = 0,
            /// Software rising edge event trigger on line
            SWI5: u1 = 0,
            /// Software rising edge event trigger on line
            SWI6: u1 = 0,
            /// Software rising edge event trigger on line
            SWI7: u1 = 0,
            /// Software rising edge event trigger on line
            SWI8: u1 = 0,
            /// Software rising edge event trigger on line
            SWI9: u1 = 0,
            /// Software rising edge event trigger on line
            SWI10: u1 = 0,
            /// Software rising edge event trigger on line
            SWI11: u1 = 0,
            /// Software rising edge event trigger on line
            SWI12: u1 = 0,
            /// Software rising edge event trigger on line
            SWI13: u1 = 0,
            /// Software rising edge event trigger on line
            SWI14: u1 = 0,
            /// Software rising edge event trigger on line
            SWI15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4002180c
        /// EXTI rising edge pending register
        pub const RPR1 = @as(*volatile Mmio(32, packed struct {
            /// Rising edge event pending for configurable line
            RPIF0: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF1: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF2: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF3: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF4: u1 = 0,
            /// configurable event inputs x rising edge Pending bit
            RPIF5: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF6: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF7: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF8: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF9: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF10: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF11: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF12: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF13: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF14: u1 = 0,
            /// Rising edge event pending for configurable line
            RPIF15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40021810
        /// EXTI falling edge pending register
        pub const FPR1 = @as(*volatile Mmio(32, packed struct {
            /// Falling edge event pending for configurable line
            FPIF0: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF1: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF2: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF3: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF4: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF5: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF6: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF7: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF8: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF9: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF10: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF11: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF12: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF13: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF14: u1 = 0,
            /// Falling edge event pending for configurable line
            FPIF15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40021860
        /// EXTI external interrupt selection register
        pub const EXTICR1 = @as(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8 = 0,
            /// GPIO port selection
            EXTI8_15: u8 = 0,
            /// GPIO port selection
            EXTI16_23: u8 = 0,
            /// GPIO port selection
            EXTI24_31: u8 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40021864
        /// EXTI external interrupt selection register
        pub const EXTICR2 = @as(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8 = 0,
            /// GPIO port selection
            EXTI8_15: u8 = 0,
            /// GPIO port selection
            EXTI16_23: u8 = 0,
            /// GPIO port selection
            EXTI24_31: u8 = 0,
        }), @ptrFromInt(base_address + 0x64));

        /// address: 0x40021868
        /// EXTI external interrupt selection register
        pub const EXTICR3 = @as(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8 = 0,
            /// GPIO port selection
            EXTI8_15: u8 = 0,
            /// GPIO port selection
            EXTI16_23: u8 = 0,
            /// GPIO port selection
            EXTI24_31: u8 = 0,
        }), @ptrFromInt(base_address + 0x68));

        /// address: 0x4002186c
        /// EXTI external interrupt selection register
        pub const EXTICR4 = @as(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8 = 0,
            /// GPIO port selection
            EXTI8_15: u8 = 0,
            /// GPIO port selection
            EXTI16_23: u8 = 0,
            /// GPIO port selection
            EXTI24_31: u8 = 0,
        }), @ptrFromInt(base_address + 0x6c));

        /// address: 0x40021880
        /// EXTI CPU wakeup with interrupt mask register
        pub const IMR1 = @as(*volatile Mmio(32, packed struct {
            /// CPU wakeup with interrupt mask on event input
            IM0: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM1: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM2: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM3: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM4: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM5: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM6: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM7: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM8: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM9: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM10: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM11: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM12: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM13: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM14: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            /// CPU wakeup with interrupt mask on event input
            IM19: u1 = 1,
            _reserved20: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM21: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM22: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM23: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM24: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM25: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM26: u1 = 1,
            _reserved27: u1 = 1,
            _reserved28: u1 = 1,
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            /// CPU wakeup with interrupt mask on event input
            IM31: u1 = 1,
        }), @ptrFromInt(base_address + 0x80));

        /// address: 0x40021884
        /// EXTI CPU wakeup with event mask register
        pub const EMR1 = @as(*volatile Mmio(32, packed struct {
            /// CPU wakeup with event mask on event input
            EM0: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM1: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM2: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM3: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM4: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM5: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM6: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM7: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM8: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM9: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM10: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM11: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM12: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM13: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM14: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM19: u1 = 0,
            _reserved20: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM21: u1 = 0,
            _reserved22: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM23: u1 = 0,
            _reserved24: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM25: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// CPU wakeup with event mask on event input
            EM31: u1 = 0,
        }), @ptrFromInt(base_address + 0x84));
    };

    /// General purpose timers
    pub const TIM16 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40014404
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded control
            CCPC: u1 = 0,
            _reserved1: u1 = 0,
            /// Capture/compare control update selection
            CCUS: u1 = 0,
            /// Capture/compare DMA selection
            CCDS: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Output Idle state 1
            OIS1: u1 = 0,
            /// Output Idle state 1
            OIS1N: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// COM interrupt enable
            COMIE: u1 = 0,
            _reserved6: u1 = 0,
            /// Break interrupt enable
            BIE: u1 = 0,
            /// Update DMA request enable
            UDE: u1 = 0,
            /// Capture/Compare 1 DMA request enable
            CC1DE: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            /// COM DMA request enable
            COMDE: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40014410
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// COM interrupt flag
            COMIF: u1 = 0,
            _reserved6: u1 = 0,
            /// Break interrupt flag
            BIF: u1 = 0,
            _reserved8: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40014414
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// Capture/Compare control update generation
            COMG: u1 = 0,
            _reserved6: u1 = 0,
            /// Break generation
            BG: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40014418
        /// capture/compare mode register (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output Compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output Compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output Compare 1 mode
            OC1M: u3 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Output Compare 1 mode
            OC1M_2: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40014418
        /// capture/compare mode register 1 (input mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Input capture 1 prescaler
            IC1PSC: u2 = 0,
            /// Input capture 1 filter
            IC1F: u4 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40014420
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            /// Capture/Compare 1 complementary output enable
            CC1NE: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40014424
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// UIF Copy
            UIFCPY: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40014428
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x4001442c
        /// auto-reload register
        pub const ARR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40014430
        /// repetition counter register
        pub const RCR = @as(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40014434
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x34));

        /// address: 0x40014444
        /// break and dead-time register
        pub const BDTR = @as(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8 = 0,
            /// Lock configuration
            LOCK: u2 = 0,
            /// Off-state selection for Idle mode
            OSSI: u1 = 0,
            /// Off-state selection for Run mode
            OSSR: u1 = 0,
            /// Break enable
            BKE: u1 = 0,
            /// Break polarity
            BKP: u1 = 0,
            /// Automatic output enable
            AOE: u1 = 0,
            /// Main output enable
            MOE: u1 = 0,
            /// Break filter
            BKF: u4 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            /// Break Disarm
            BKDSRM: u1 = 0,
            _reserved27: u1 = 0,
            /// Break Bidirectional
            BKBID: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40014448
        /// DMA control register
        pub const DCR = @as(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// DMA burst length
            DBL: u5 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4001444c
        /// DMA address for full transfer
        pub const DMAR = @as(*volatile Mmio(32, packed struct {
            /// DMA register for burst accesses
            DMAB: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40014460
        /// TIM17 option register 1
        pub const AF1 = @as(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1 = 0,
            /// BRK COMP1 enable
            BKCMP1E: u1 = 0,
            /// BRK COMP2 enable
            BKCMP2E: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// BRK DFSDM_BREAK1 enable
            BKDFBK1E: u1 = 0,
            /// BRK BKIN input polarity
            BKINP: u1 = 0,
            /// BRK COMP1 input polarity
            BKCMP1P: u1 = 0,
            /// BRK COMP2 input polarit
            BKCMP2P: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40014468
        /// input selection register
        pub const TISEL = @as(*volatile Mmio(32, packed struct {
            /// selects input
            TI1SEL: u4 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x68));
    };
    pub const TIM17 = struct {
        pub const base_address = 0x40014800;

        /// address: 0x40014800
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40014804
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded control
            CCPC: u1 = 0,
            _reserved1: u1 = 0,
            /// Capture/compare control update selection
            CCUS: u1 = 0,
            /// Capture/compare DMA selection
            CCDS: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Output Idle state 1
            OIS1: u1 = 0,
            /// Output Idle state 1
            OIS1N: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x4001480c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// COM interrupt enable
            COMIE: u1 = 0,
            _reserved6: u1 = 0,
            /// Break interrupt enable
            BIE: u1 = 0,
            /// Update DMA request enable
            UDE: u1 = 0,
            /// Capture/Compare 1 DMA request enable
            CC1DE: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            /// COM DMA request enable
            COMDE: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40014810
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// COM interrupt flag
            COMIF: u1 = 0,
            _reserved6: u1 = 0,
            /// Break interrupt flag
            BIF: u1 = 0,
            _reserved8: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40014814
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            /// Capture/Compare control update generation
            COMG: u1 = 0,
            _reserved6: u1 = 0,
            /// Break generation
            BG: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40014818
        /// capture/compare mode register (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output Compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output Compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output Compare 1 mode
            OC1M: u3 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Output Compare 1 mode
            OC1M_2: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40014818
        /// capture/compare mode register 1 (input mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Input capture 1 prescaler
            IC1PSC: u2 = 0,
            /// Input capture 1 filter
            IC1F: u4 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40014820
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            /// Capture/Compare 1 complementary output enable
            CC1NE: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40014824
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// UIF Copy
            UIFCPY: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40014828
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x4001482c
        /// auto-reload register
        pub const ARR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40014830
        /// repetition counter register
        pub const RCR = @as(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40014834
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x34));

        /// address: 0x40014844
        /// break and dead-time register
        pub const BDTR = @as(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8 = 0,
            /// Lock configuration
            LOCK: u2 = 0,
            /// Off-state selection for Idle mode
            OSSI: u1 = 0,
            /// Off-state selection for Run mode
            OSSR: u1 = 0,
            /// Break enable
            BKE: u1 = 0,
            /// Break polarity
            BKP: u1 = 0,
            /// Automatic output enable
            AOE: u1 = 0,
            /// Main output enable
            MOE: u1 = 0,
            /// Break filter
            BKF: u4 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            /// Break Disarm
            BKDSRM: u1 = 0,
            _reserved27: u1 = 0,
            /// Break Bidirectional
            BKBID: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40014848
        /// DMA control register
        pub const DCR = @as(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// DMA burst length
            DBL: u5 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4001484c
        /// DMA address for full transfer
        pub const DMAR = @as(*volatile Mmio(32, packed struct {
            /// DMA register for burst accesses
            DMAB: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40014860
        /// TIM17 option register 1
        pub const AF1 = @as(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1 = 0,
            /// BRK COMP1 enable
            BKCMP1E: u1 = 0,
            /// BRK COMP2 enable
            BKCMP2E: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// BRK DFSDM_BREAK1 enable
            BKDFBK1E: u1 = 0,
            /// BRK BKIN input polarity
            BKINP: u1 = 0,
            /// BRK COMP1 input polarity
            BKCMP1P: u1 = 0,
            /// BRK COMP2 input polarit
            BKCMP2P: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40014868
        /// input selection register
        pub const TISEL = @as(*volatile Mmio(32, packed struct {
            /// selects input
            TI1SEL: u4 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x68));
    };

    /// Universal synchronous asynchronous receiver transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Control register 1
        pub const CR1 = @as(*volatile Mmio(32, rt.usart.CR1), @ptrFromInt(base_address + 0x0));

        /// address: 0x40013804
        /// Control register 2
        pub const CR2 = @as(*volatile Mmio(32, rt.usart.CR2), @ptrFromInt(base_address + 0x4));

        /// address: 0x40013808
        /// Control register 3
        pub const CR3 = @as(*volatile Mmio(32, rt.usart.CR3), @ptrFromInt(base_address + 0x8));

        /// address: 0x4001380c
        /// Baud rate register
        pub const BRR = @as(*volatile Mmio(32, rt.usart.BRR), @ptrFromInt(base_address + 0xc));

        /// address: 0x40013810
        /// Guard time and prescaler register
        pub const GTPR = @as(*volatile Mmio(32, rt.usart.GTPR), @ptrFromInt(base_address + 0x10));

        /// address: 0x40013814
        /// Receiver timeout register
        pub const RTOR = @as(*volatile Mmio(32, rt.usart.RTOR), @ptrFromInt(base_address + 0x14));

        /// address: 0x40013818
        /// Request register
        pub const RQR = @as(*volatile Mmio(32, rt.usart.RQR), @ptrFromInt(base_address + 0x18));

        /// address: 0x4001381c
        /// Interrupt & status register
        pub const ISR = @as(*volatile Mmio(32, rt.usart.ISR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40013820
        /// Interrupt flag clear register
        pub const ICR = @as(*volatile Mmio(32, rt.usart.ICR), @ptrFromInt(base_address + 0x20));

        /// address: 0x40013824
        /// Receive data register
        pub const RDR = @as(*volatile MmioInt(32, u9), @ptrFromInt(base_address + 0x24));

        /// address: 0x40013828
        /// Transmit data register
        pub const TDR = @as(*volatile MmioInt(32, u9), @ptrFromInt(base_address + 0x28));

        /// address: 0x4001382c
        /// Prescaler register
        pub const PRESC = @as(*volatile Mmio(32, rt.usart.PRESC), @ptrFromInt(base_address + 0x2c));
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @as(*volatile Mmio(32, rt.usart.CR1), @ptrFromInt(base_address + 0x0));

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @as(*volatile Mmio(32, rt.usart.CR2), @ptrFromInt(base_address + 0x4));

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @as(*volatile Mmio(32, rt.usart.CR3), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @as(*volatile Mmio(32, rt.usart.BRR), @ptrFromInt(base_address + 0xc));

        /// address: 0x40004410
        /// Guard time and prescaler register
        pub const GTPR = @as(*volatile Mmio(32, rt.usart.GTPR), @ptrFromInt(base_address + 0x10));

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @as(*volatile Mmio(32, rt.usart.RTOR), @ptrFromInt(base_address + 0x14));

        /// address: 0x40004418
        /// Request register
        pub const RQR = @as(*volatile Mmio(32, rt.usart.RQR), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000441c
        /// Interrupt & status register
        pub const ISR = @as(*volatile Mmio(32, rt.usart.ISR), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @as(*volatile Mmio(32, rt.usart.ICR), @ptrFromInt(base_address + 0x20));

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @as(*volatile MmioInt(32, u9), @ptrFromInt(base_address + 0x24));

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @as(*volatile MmioInt(32, u9), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000442c
        /// Prescaler register
        pub const PRESC = @as(*volatile Mmio(32, rt.usart.PRESC), @ptrFromInt(base_address + 0x2c));
    };

    /// Serial peripheral interface/Inter-IC sound
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1 = 0,
            /// Clock polarity
            CPOL: u1 = 0,
            /// Master selection
            MSTR: u1 = 0,
            /// Baud rate control
            BR: u3 = 0,
            /// SPI enable
            SPE: u1 = 0,
            /// Frame format
            LSBFIRST: u1 = 0,
            /// Internal slave select
            SSI: u1 = 0,
            /// Software slave management
            SSM: u1 = 0,
            /// Receive only
            RXONLY: u1 = 0,
            /// Data frame format
            DFF: u1 = 0,
            /// CRC transfer next
            CRCNEXT: u1 = 0,
            /// Hardware CRC calculation enable
            CRCEN: u1 = 0,
            /// Output enable in bidirectional mode
            BIDIOE: u1 = 0,
            /// Bidirectional data mode enable
            BIDIMODE: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1 = 0,
            /// Tx buffer DMA enable
            TXDMAEN: u1 = 0,
            /// SS output enable
            SSOE: u1 = 0,
            /// NSS pulse management
            NSSP: u1 = 0,
            /// Frame format
            FRF: u1 = 0,
            /// Error interrupt enable
            ERRIE: u1 = 0,
            /// RX buffer not empty interrupt enable
            RXNEIE: u1 = 0,
            /// Tx buffer empty interrupt enable
            TXEIE: u1 = 0,
            /// Data size
            DS: u4 = 0,
            /// FIFO reception threshold
            FRXTH: u1 = 0,
            /// Last DMA transfer for reception
            LDMA_RX: u1 = 0,
            /// Last DMA transfer for transmission
            LDMA_TX: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40013008
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1 = 0,
            /// Transmit buffer empty
            TXE: u1 = 1,
            /// Channel side
            CHSIDE: u1 = 0,
            /// Underrun flag
            UDR: u1 = 0,
            /// CRC error flag
            CRCERR: u1 = 0,
            /// Mode fault
            MODF: u1 = 0,
            /// Overrun flag
            OVR: u1 = 0,
            /// Busy flag
            BSY: u1 = 0,
            /// TI frame format error
            TIFRFE: u1 = 0,
            /// FIFO reception level
            FRLVL: u2 = 0,
            /// FIFO transmission level
            FTLVL: u2 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4001300c
        /// data register
        pub const DR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0xc));

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @as(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16 = 7,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @as(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @as(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4001301c
        /// configuration register
        pub const I2SCFGR = @as(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio channel)
            CHLEN: u1 = 0,
            /// Data length to be transferred
            DATLEN: u2 = 0,
            /// Inactive state clock polarity
            CKPOL: u1 = 0,
            /// standard selection
            I2SSTD: u2 = 0,
            _reserved6: u1 = 0,
            /// PCM frame synchronization
            PCMSYNC: u1 = 0,
            /// I2S configuration mode
            I2SCFG: u2 = 0,
            /// I2S enable
            SE2: u1 = 0,
            /// I2S mode selection
            I2SMOD: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40013020
        /// prescaler register
        pub const I2SPR = @as(*volatile Mmio(32, packed struct {
            /// linear prescaler
            I2SDIV: u8 = 0,
            /// Odd factor for the prescaler
            ODD: u1 = 0,
            /// Master clock output enable
            MCKOE: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1 = 0,
            /// Clock polarity
            CPOL: u1 = 0,
            /// Master selection
            MSTR: u1 = 0,
            /// Baud rate control
            BR: u3 = 0,
            /// SPI enable
            SPE: u1 = 0,
            /// Frame format
            LSBFIRST: u1 = 0,
            /// Internal slave select
            SSI: u1 = 0,
            /// Software slave management
            SSM: u1 = 0,
            /// Receive only
            RXONLY: u1 = 0,
            /// Data frame format
            DFF: u1 = 0,
            /// CRC transfer next
            CRCNEXT: u1 = 0,
            /// Hardware CRC calculation enable
            CRCEN: u1 = 0,
            /// Output enable in bidirectional mode
            BIDIOE: u1 = 0,
            /// Bidirectional data mode enable
            BIDIMODE: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1 = 0,
            /// Tx buffer DMA enable
            TXDMAEN: u1 = 0,
            /// SS output enable
            SSOE: u1 = 0,
            /// NSS pulse management
            NSSP: u1 = 0,
            /// Frame format
            FRF: u1 = 0,
            /// Error interrupt enable
            ERRIE: u1 = 0,
            /// RX buffer not empty interrupt enable
            RXNEIE: u1 = 0,
            /// Tx buffer empty interrupt enable
            TXEIE: u1 = 0,
            /// Data size
            DS: u4 = 0,
            /// FIFO reception threshold
            FRXTH: u1 = 0,
            /// Last DMA transfer for reception
            LDMA_RX: u1 = 0,
            /// Last DMA transfer for transmission
            LDMA_TX: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40003808
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1 = 0,
            /// Transmit buffer empty
            TXE: u1 = 1,
            /// Channel side
            CHSIDE: u1 = 0,
            /// Underrun flag
            UDR: u1 = 0,
            /// CRC error flag
            CRCERR: u1 = 0,
            /// Mode fault
            MODF: u1 = 0,
            /// Overrun flag
            OVR: u1 = 0,
            /// Busy flag
            BSY: u1 = 0,
            /// TI frame format error
            TIFRFE: u1 = 0,
            /// FIFO reception level
            FRLVL: u2 = 0,
            /// FIFO transmission level
            FTLVL: u2 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000380c
        /// data register
        pub const DR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0xc));

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @as(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16 = 7,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @as(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @as(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000381c
        /// configuration register
        pub const I2SCFGR = @as(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio channel)
            CHLEN: u1 = 0,
            /// Data length to be transferred
            DATLEN: u2 = 0,
            /// Inactive state clock polarity
            CKPOL: u1 = 0,
            /// standard selection
            I2SSTD: u2 = 0,
            _reserved6: u1 = 0,
            /// PCM frame synchronization
            PCMSYNC: u1 = 0,
            /// I2S configuration mode
            I2SCFG: u2 = 0,
            /// I2S enable
            SE2: u1 = 0,
            /// I2S mode selection
            I2SMOD: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40003820
        /// prescaler register
        pub const I2SPR = @as(*volatile Mmio(32, packed struct {
            /// linear prescaler
            I2SDIV: u8 = 0,
            /// Odd factor for the prescaler
            ODD: u1 = 0,
            /// Master clock output enable
            MCKOE: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));
    };

    /// Advanced-timers
    pub const TIM1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            /// Direction
            DIR: u1 = 0,
            /// Center-aligned mode selection
            CMS: u2 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40012c04
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded control
            CCPC: u1 = 0,
            _reserved1: u1 = 0,
            /// Capture/compare control update selection
            CCUS: u1 = 0,
            /// Capture/compare DMA selection
            CCDS: u1 = 0,
            /// Master mode selection
            MMS: u3 = 0,
            /// TI1 selection
            TI1S: u1 = 0,
            /// Output Idle state 1
            OIS1: u1 = 0,
            /// Output Idle state 1
            OIS1N: u1 = 0,
            /// Output Idle state 2
            OIS2: u1 = 0,
            /// Output Idle state 2
            OIS2N: u1 = 0,
            /// Output Idle state 3
            OIS3: u1 = 0,
            /// Output Idle state 3
            OIS3N: u1 = 0,
            /// Output Idle state 4
            OIS4: u1 = 0,
            _reserved15: u1 = 0,
            /// Output Idle state 5 (OC5 output)
            OIS5: u1 = 0,
            _reserved17: u1 = 0,
            /// Output Idle state 6 (OC6 output)
            OIS6: u1 = 0,
            _reserved19: u1 = 0,
            /// Master mode selection 2
            MMS2: u4 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40012c08
        /// slave mode control register
        pub const SMCR = @as(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3 = 0,
            /// OCREF clear selection
            OCCS: u1 = 0,
            /// Trigger selection
            TS_4: u3 = 0,
            /// Master/Slave mode
            MSM: u1 = 0,
            /// External trigger filter
            ETF: u4 = 0,
            /// External trigger prescaler
            ETPS: u2 = 0,
            /// External clock enable
            ECE: u1 = 0,
            /// External trigger polarity
            ETP: u1 = 0,
            /// Slave mode selection - bit 3
            SMS_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            /// Trigger selection
            TS: u2 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            /// Capture/Compare 2 interrupt enable
            CC2IE: u1 = 0,
            /// Capture/Compare 3 interrupt enable
            CC3IE: u1 = 0,
            /// Capture/Compare 4 interrupt enable
            CC4IE: u1 = 0,
            /// COM interrupt enable
            COMIE: u1 = 0,
            /// Trigger interrupt enable
            TIE: u1 = 0,
            /// Break interrupt enable
            BIE: u1 = 0,
            /// Update DMA request enable
            UDE: u1 = 0,
            /// Capture/Compare 1 DMA request enable
            CC1DE: u1 = 0,
            /// Capture/Compare 2 DMA request enable
            CC2DE: u1 = 0,
            /// Capture/Compare 3 DMA request enable
            CC3DE: u1 = 0,
            /// Capture/Compare 4 DMA request enable
            CC4DE: u1 = 0,
            /// COM DMA request enable
            COMDE: u1 = 0,
            /// Trigger DMA request enable
            TDE: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40012c10
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            /// Capture/Compare 2 interrupt flag
            CC2IF: u1 = 0,
            /// Capture/Compare 3 interrupt flag
            CC3IF: u1 = 0,
            /// Capture/Compare 4 interrupt flag
            CC4IF: u1 = 0,
            /// COM interrupt flag
            COMIF: u1 = 0,
            /// Trigger interrupt flag
            TIF: u1 = 0,
            /// Break interrupt flag
            BIF: u1 = 0,
            /// Break 2 interrupt flag
            B2IF: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            /// Capture/compare 2 overcapture flag
            CC2OF: u1 = 0,
            /// Capture/Compare 3 overcapture flag
            CC3OF: u1 = 0,
            /// Capture/Compare 4 overcapture flag
            CC4OF: u1 = 0,
            /// System Break interrupt flag
            SBIF: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Compare 5 interrupt flag
            CC5IF: u1 = 0,
            /// Compare 6 interrupt flag
            CC6IF: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40012c14
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            /// Capture/compare 2 generation
            CC2G: u1 = 0,
            /// Capture/compare 3 generation
            CC3G: u1 = 0,
            /// Capture/compare 4 generation
            CC4G: u1 = 0,
            /// Capture/Compare control update generation
            COMG: u1 = 0,
            /// Trigger generation
            TG: u1 = 0,
            /// Break generation
            BG: u1 = 0,
            /// Break 2 generation
            B2G: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40012c18
        /// capture/compare mode register 1 (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output Compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output Compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output Compare 1 mode
            OC1M: u3 = 0,
            /// Output Compare 1 clear enable
            OC1CE: u1 = 0,
            /// Capture/Compare 2 selection
            CC2S: u2 = 0,
            /// Output Compare 2 fast enable
            OC2FE: u1 = 0,
            /// Output Compare 2 preload enable
            OC2PE: u1 = 0,
            /// Output Compare 2 mode
            OC2M: u3 = 0,
            /// Output Compare 2 clear enable
            OC2CE: u1 = 0,
            /// Output Compare 1 mode - bit 3
            OC1M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 2 mode - bit 3
            OC2M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40012c18
        /// capture/compare mode register 1 (output mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output Compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output Compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output Compare 1 mode
            OC1M: u3 = 0,
            /// Output Compare 1 clear enable
            OC1CE: u1 = 0,
            /// Capture/Compare 2 selection
            CC2S: u2 = 0,
            /// Output Compare 2 fast enable
            OC2FE: u1 = 0,
            /// Output Compare 2 preload enable
            OC2PE: u1 = 0,
            /// Output Compare 2 mode
            OC2M: u3 = 0,
            /// Output Compare 2 clear enable
            OC2CE: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (output mode)
        pub const CCMR2_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Output compare 3 fast enable
            OC3FE: u1 = 0,
            /// Output compare 3 preload enable
            OC3PE: u1 = 0,
            /// Output compare 3 mode
            OC3M: u3 = 0,
            /// Output compare 3 clear enable
            OC3CE: u1 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Output compare 4 fast enable
            OC4FE: u1 = 0,
            /// Output compare 4 preload enable
            OC4PE: u1 = 0,
            /// Output compare 4 mode
            OC4M: u3 = 0,
            /// Output compare 4 clear enable
            OC4CE: u1 = 0,
            /// Output Compare 3 mode - bit 3
            OC3M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 4 mode - bit 3
            OC4M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (output mode)
        pub const CCMR2_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Output compare 3 fast enable
            OC3FE: u1 = 0,
            /// Output compare 3 preload enable
            OC3PE: u1 = 0,
            /// Output compare 3 mode
            OC3M: u3 = 0,
            /// Output compare 3 clear enable
            OC3CE: u1 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Output compare 4 fast enable
            OC4FE: u1 = 0,
            /// Output compare 4 preload enable
            OC4PE: u1 = 0,
            /// Output compare 4 mode
            OC4M: u3 = 0,
            /// Output compare 4 clear enable
            OC4CE: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40012c20
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            /// Capture/Compare 1 complementary output enable
            CC1NE: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            /// Capture/Compare 2 output enable
            CC2E: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2P: u1 = 0,
            /// Capture/Compare 2 complementary output enable
            CC2NE: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2NP: u1 = 0,
            /// Capture/Compare 3 output enable
            CC3E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3P: u1 = 0,
            /// Capture/Compare 3 complementary output enable
            CC3NE: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3NP: u1 = 0,
            /// Capture/Compare 4 output enable
            CC4E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC4P: u1 = 0,
            _reserved14: u1 = 0,
            /// Capture/Compare 4 complementary output polarity
            CC4NP: u1 = 0,
            /// Capture/Compare 5 output enable
            CC5E: u1 = 0,
            /// Capture/Compare 5 output polarity
            CC5P: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            /// Capture/Compare 6 output enable
            CC6E: u1 = 0,
            /// Capture/Compare 6 output polarity
            CC6P: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40012c24
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// UIF copy
            UIFCPY: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x40012c2c
        /// auto-reload register
        pub const ARR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40012c30
        /// repetition counter register
        pub const RCR = @as(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40012c34
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x34));

        /// address: 0x40012c38
        /// capture/compare register 2
        pub const CCR2 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x38));

        /// address: 0x40012c3c
        /// capture/compare register 3
        pub const CCR3 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40012c40
        /// capture/compare register 4
        pub const CCR4 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x40));

        /// address: 0x40012c44
        /// break and dead-time register
        pub const BDTR = @as(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8 = 0,
            /// Lock configuration
            LOCK: u2 = 0,
            /// Off-state selection for Idle mode
            OSSI: u1 = 0,
            /// Off-state selection for Run mode
            OSSR: u1 = 0,
            /// Break enable
            BKE: u1 = 0,
            /// Break polarity
            BKP: u1 = 0,
            /// Automatic output enable
            AOE: u1 = 0,
            /// Main output enable
            MOE: u1 = 0,
            /// Break filter
            BKF: u4 = 0,
            /// Break 2 filter
            BK2F: u4 = 0,
            /// Break 2 enable
            BK2E: u1 = 0,
            /// Break 2 polarity
            BK2P: u1 = 0,
            /// Break Disarm
            BKDSRM: u1 = 0,
            /// Break2 Disarm
            BK2DSRM: u1 = 0,
            /// Break Bidirectional
            BKBID: u1 = 0,
            /// Break2 bidirectional
            BK2ID: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40012c48
        /// DMA control register
        pub const DCR = @as(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// DMA burst length
            DBL: u5 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x40012c4c
        /// DMA address for full transfer
        pub const DMAR = @as(*volatile Mmio(32, packed struct {
            /// DMA register for burst accesses
            DMAB: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40012c50
        /// option register 1
        pub const OR1 = @as(*volatile Mmio(32, packed struct {
            /// Ocref_clr source selection
            OCREF_CLR: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));

        /// address: 0x40012c54
        /// capture/compare mode register 2 (output mode)
        pub const CCMR3_Output = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            /// Output compare 5 fast enable
            OC5FE: u1 = 0,
            /// Output compare 5 preload enable
            OC5PE: u1 = 0,
            /// Output compare 5 mode
            OC5M: u3 = 0,
            /// Output compare 5 clear enable
            OC5CE: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            /// Output compare 6 fast enable
            OC6FE: u1 = 0,
            /// Output compare 6 preload enable
            OC6PE: u1 = 0,
            /// Output compare 6 mode
            OC6M: u3 = 0,
            /// Output compare 6 clear enable
            OC6CE: u1 = 0,
            /// Output Compare 5 mode bit 3
            OC5M_bit3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 6 mode bit 3
            OC6M_bit3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x54));

        /// address: 0x40012c58
        /// capture/compare register 4
        pub const CCR5 = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare value
            CCR5: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            /// Group Channel 5 and Channel 1
            GC5C1: u1 = 0,
            /// Group Channel 5 and Channel 2
            GC5C2: u1 = 0,
            /// Group Channel 5 and Channel 3
            GC5C3: u1 = 0,
        }), @ptrFromInt(base_address + 0x58));

        /// address: 0x40012c5c
        /// capture/compare register 4
        pub const CCR6 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x5c));

        /// address: 0x40012c60
        /// DMA address for full transfer
        pub const AF1 = @as(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1 = 1,
            /// BRK COMP1 enable
            BKCMP1E: u1 = 0,
            /// BRK COMP2 enable
            BKCMP2E: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            /// BRK BKIN input polarity
            BKINP: u1 = 0,
            /// BRK COMP1 input polarity
            BKCMP1P: u1 = 0,
            /// BRK COMP2 input polarity
            BKCMP2P: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// ETR source selection
            ETRSEL: u3 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40012c64
        /// DMA address for full transfer
        pub const AF2 = @as(*volatile Mmio(32, packed struct {
            /// BRK2 BKIN input enable
            BK2INE: u1 = 1,
            /// BRK2 COMP1 enable
            BK2CMP1E: u1 = 0,
            /// BRK2 COMP2 enable
            BK2CMP2E: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// BRK2 DFSDM_BREAK0 enable
            BK2DFBK0E: u1 = 0,
            /// BRK2 BKIN input polarity
            BK2INP: u1 = 0,
            /// BRK2 COMP1 input polarity
            BK2CMP1P: u1 = 0,
            /// BRK2 COMP2 input polarity
            BK2CMP2P: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x64));

        /// address: 0x40012c68
        /// TIM1 timer input selection register
        pub const TISEL = @as(*volatile Mmio(32, packed struct {
            /// selects TI1[0] to TI1[15] input
            TI1SEL3_0: u4 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// selects TI2[0] to TI2[15] input
            TI2SEL3_0: u4 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// selects TI3[0] to TI3[15] input
            TI3SEL3_0: u4 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// selects TI4[0] to TI4[15] input
            TI4SEL3_0: u4 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x68));
    };

    /// System configuration controller
    pub const SYSCFG = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// SYSCFG configuration register 1
        pub const CFGR1 = @as(*volatile Mmio(32, packed struct {
            /// Memory mapping selection bits
            MEM_MODE: u2 = 0,
            _reserved2: u1 = 0,
            /// PA11_RMP
            PA11_RMP: u1 = 0,
            /// PA11 and PA12 remapping bit.
            PA12_RMP: u1 = 0,
            /// IR output polarity selection
            IR_POL: u1 = 0,
            /// IR Modulation Envelope signal selection.
            IR_MOD: u2 = 0,
            /// I/O analog switch voltage booster enable
            BOOSTEN: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Fast Mode Plus (FM+) enable for PB6
            I2C_PB6_FMP: u1 = 0,
            /// Fast Mode Plus (FM+) enable for PB7
            I2C_PB7_FMP: u1 = 0,
            /// Fast Mode Plus (FM+) enable for PB8
            I2C_PB8_FMP: u1 = 0,
            /// Fast Mode Plus (FM+) enable for PB9
            I2C_PB9_FMP: u1 = 0,
            /// FM+ driving capability activation for I2C1
            I2C1_FMP: u1 = 0,
            /// FM+ driving capability activation for I2C2
            I2C2_FMP: u1 = 0,
            /// Fast Mode Plus (FM+) driving capability activation bits
            I2C_PA9_FMP: u1 = 0,
            /// Fast Mode Plus (FM+) driving capability activation bits
            I2C_PA10_FMP: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40010018
        /// SYSCFG configuration register 1
        pub const CFGR2 = @as(*volatile Mmio(32, packed struct {
            /// Cortex-M0+ LOCKUP bit enable bit
            LOCKUP_LOCK: u1 = 0,
            /// SRAM parity lock bit
            SRAM_PARITY_LOCK: u1 = 0,
            _reserved2: u1 = 0,
            /// ECC error lock bit
            ECC_LOCK: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// SRAM parity error flag
            SRAM_PEF: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40010080
        /// interrupt line 0 status register
        pub const ITLINE0 = @as(*volatile Mmio(32, packed struct {
            /// Window watchdog interrupt pending flag
            WWDG: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x80));

        /// address: 0x40010088
        /// interrupt line 2 status register
        pub const ITLINE2 = @as(*volatile Mmio(32, packed struct {
            /// TAMP
            TAMP: u1 = 0,
            /// RTC
            RTC: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x88));

        /// address: 0x4001008c
        /// interrupt line 3 status register
        pub const ITLINE3 = @as(*volatile Mmio(32, packed struct {
            /// FLASH_ITF
            FLASH_ITF: u1 = 0,
            /// FLASH_ECC
            FLASH_ECC: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8c));

        /// address: 0x40010090
        /// interrupt line 4 status register
        pub const ITLINE4 = @as(*volatile Mmio(32, packed struct {
            /// RCC
            RCC: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x90));

        /// address: 0x40010094
        /// interrupt line 5 status register
        pub const ITLINE5 = @as(*volatile Mmio(32, packed struct {
            /// EXTI0
            EXTI0: u1 = 0,
            /// EXTI1
            EXTI1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x94));

        /// address: 0x40010098
        /// interrupt line 6 status register
        pub const ITLINE6 = @as(*volatile Mmio(32, packed struct {
            /// EXTI2
            EXTI2: u1 = 0,
            /// EXTI3
            EXTI3: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x98));

        /// address: 0x4001009c
        /// interrupt line 7 status register
        pub const ITLINE7 = @as(*volatile Mmio(32, packed struct {
            /// EXTI4
            EXTI4: u1 = 0,
            /// EXTI5
            EXTI5: u1 = 0,
            /// EXTI6
            EXTI6: u1 = 0,
            /// EXTI7
            EXTI7: u1 = 0,
            /// EXTI8
            EXTI8: u1 = 0,
            /// EXTI9
            EXTI9: u1 = 0,
            /// EXTI10
            EXTI10: u1 = 0,
            /// EXTI11
            EXTI11: u1 = 0,
            /// EXTI12
            EXTI12: u1 = 0,
            /// EXTI13
            EXTI13: u1 = 0,
            /// EXTI14
            EXTI14: u1 = 0,
            /// EXTI15
            EXTI15: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x9c));

        /// address: 0x400100a4
        /// interrupt line 9 status register
        pub const ITLINE9 = @as(*volatile Mmio(32, packed struct {
            /// DMA1_CH1
            DMA1_CH1: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xa4));

        /// address: 0x400100a8
        /// interrupt line 10 status register
        pub const ITLINE10 = @as(*volatile Mmio(32, packed struct {
            /// DMA1_CH1
            DMA1_CH2: u1 = 0,
            /// DMA1_CH3
            DMA1_CH3: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xa8));

        /// address: 0x400100ac
        /// interrupt line 11 status register
        pub const ITLINE11 = @as(*volatile Mmio(32, packed struct {
            /// DMAMUX
            DMAMUX: u1 = 0,
            /// DMA1_CH4
            DMA1_CH4: u1 = 0,
            /// DMA1_CH5
            DMA1_CH5: u1 = 0,
            /// DMA1_CH6
            DMA1_CH6: u1 = 0,
            /// DMA1_CH7
            DMA1_CH7: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xac));

        /// address: 0x400100b0
        /// interrupt line 12 status register
        pub const ITLINE12 = @as(*volatile Mmio(32, packed struct {
            /// ADC
            ADC: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xb0));

        /// address: 0x400100b4
        /// interrupt line 13 status register
        pub const ITLINE13 = @as(*volatile Mmio(32, packed struct {
            /// TIM1_CCU
            TIM1_CCU: u1 = 0,
            /// TIM1_TRG
            TIM1_TRG: u1 = 0,
            /// TIM1_UPD
            TIM1_UPD: u1 = 0,
            /// TIM1_BRK
            TIM1_BRK: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xb4));

        /// address: 0x400100b8
        /// interrupt line 14 status register
        pub const ITLINE14 = @as(*volatile Mmio(32, packed struct {
            /// TIM1_CC
            TIM1_CC: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xb8));

        /// address: 0x400100c0
        /// interrupt line 16 status register
        pub const ITLINE16 = @as(*volatile Mmio(32, packed struct {
            /// TIM3
            TIM3: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc0));

        /// address: 0x400100cc
        /// interrupt line 19 status register
        pub const ITLINE19 = @as(*volatile Mmio(32, packed struct {
            /// TIM14
            TIM14: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xcc));

        /// address: 0x400100d4
        /// interrupt line 21 status register
        pub const ITLINE21 = @as(*volatile Mmio(32, packed struct {
            /// TIM16
            TIM16: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xd4));

        /// address: 0x400100d8
        /// interrupt line 22 status register
        pub const ITLINE22 = @as(*volatile Mmio(32, packed struct {
            /// TIM17
            TIM17: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xd8));

        /// address: 0x400100dc
        /// interrupt line 23 status register
        pub const ITLINE23 = @as(*volatile Mmio(32, packed struct {
            /// I2C1
            I2C1: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xdc));

        /// address: 0x400100e0
        /// interrupt line 24 status register
        pub const ITLINE24 = @as(*volatile Mmio(32, packed struct {
            /// I2C2
            I2C2: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xe0));

        /// address: 0x400100e4
        /// interrupt line 25 status register
        pub const ITLINE25 = @as(*volatile Mmio(32, packed struct {
            /// SPI1
            SPI1: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xe4));

        /// address: 0x400100e8
        /// interrupt line 26 status register
        pub const ITLINE26 = @as(*volatile Mmio(32, packed struct {
            /// SPI2
            SPI2: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xe8));

        /// address: 0x400100ec
        /// interrupt line 27 status register
        pub const ITLINE27 = @as(*volatile Mmio(32, packed struct {
            /// USART1
            USART1: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xec));

        /// address: 0x400100f0
        /// interrupt line 28 status register
        pub const ITLINE28 = @as(*volatile Mmio(32, packed struct {
            /// USART2
            USART2: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xf0));
    };

    /// Tamper and backup registers
    pub const TAMP = struct {
        pub const base_address = 0x4000b000;

        /// address: 0x4000b000
        /// TAMP control register 1
        pub const TAMP_CR1 = @as(*volatile Mmio(32, packed struct {
            /// Tamper detection on TAMP_IN1 enable
            TAMP1E: u1 = 0,
            /// Tamper detection on TAMP_IN2 enable
            TAMP2E: u1 = 0,
            /// Tamper detection on TAMP_IN3 enable
            TAMP3E: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 1,
            _reserved17: u1 = 1,
            /// Internal tamper 3 enable: LSE monitoring
            ITAMP3E: u1 = 1,
            /// Internal tamper 4 enable: HSE monitoring
            ITAMP4E: u1 = 1,
            /// Internal tamper 5 enable: RTC calendar overflow
            ITAMP5E: u1 = 1,
            /// Internal tamper 6 enable: ST manufacturer readout
            ITAMP6E: u1 = 1,
            _reserved22: u1 = 1,
            _reserved23: u1 = 1,
            _reserved24: u1 = 1,
            _reserved25: u1 = 1,
            _reserved26: u1 = 1,
            _reserved27: u1 = 1,
            _reserved28: u1 = 1,
            _reserved29: u1 = 1,
            _reserved30: u1 = 1,
            _reserved31: u1 = 1,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x4000b004
        /// TAMP control register 2
        pub const TAMP_CR2 = @as(*volatile Mmio(32, packed struct {
            /// Tamper 1 no erase
            TAMP1NOER: u1 = 0,
            /// Tamper 2 no erase
            TAMP2NOER: u1 = 0,
            /// Tamper 3 no erase
            TAMP3NOER: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Tamper 1 mask
            /// The tamper 1 interrupt must not be enabled when TAMP1MSK is set.
            TAMP1MSK: u1 = 0,
            /// Tamper 2 mask
            /// The tamper 2 interrupt must not be enabled when TAMP2MSK is set.
            TAMP2MSK: u1 = 0,
            /// Tamper 3 mask
            /// The tamper 3 interrupt must not be enabled when TAMP3MSK is set.
            TAMP3MSK: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Active level for tamper 1 input (active mode disabled)
            /// If TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper
            /// detection event.
            /// If TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper
            /// detection event.
            TAMP1TRG: u1 = 0,
            /// Active level for tamper 2 input (active mode disabled)
            /// If TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper
            /// detection event.
            /// If TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper
            /// detection event.
            TAMP2TRG: u1 = 0,
            /// Active level for tamper 3 input (active mode disabled)
            /// If TAMPFLT = 00 Tamper 3 input rising edge and high level triggers a tamper
            /// detection event.
            /// If TAMPFLT = 00 Tamper 3 input falling edge and low level triggers a tamper
            /// detection event.
            TAMP3TRG: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x4000b00c
        /// TAMP filter control register
        pub const TAMP_FLTCR = @as(*volatile Mmio(32, packed struct {
            /// Tamper sampling frequency
            /// Determines the frequency at which each of the TAMP_INx inputs are sampled.
            TAMPFREQ: u3 = 0,
            /// TAMP_INx filter count
            /// These bits determines the number of consecutive samples at the specified level
            /// (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the
            /// TAMP_INx inputs.
            TAMPFLT: u2 = 0,
            /// TAMP_INx precharge duration
            /// These bit determines the duration of time during which the pull-up/is activated
            /// before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
            TAMPPRCH: u2 = 0,
            /// TAMP_INx pull-up disable
            /// This bit determines if each of the TAMPx pins are precharged before each sample.
            TAMPPUDIS: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x4000b02c
        /// TAMP interrupt enable register
        pub const TAMP_IER = @as(*volatile Mmio(32, packed struct {
            /// Tamper 1 interrupt enable
            TAMP1IE: u1 = 0,
            /// Tamper 2 interrupt enable
            TAMP2IE: u1 = 0,
            /// Tamper 3 interrupt enable
            TAMP3IE: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            /// Internal tamper 3 interrupt enable: LSE monitoring
            ITAMP3IE: u1 = 0,
            /// Internal tamper 4 interrupt enable: HSE monitoring
            ITAMP4IE: u1 = 0,
            /// Internal tamper 5 interrupt enable: RTC calendar overflow
            ITAMP5IE: u1 = 0,
            /// Internal tamper 6 interrupt enable: ST manufacturer readout
            ITAMP6IE: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x4000b030
        /// TAMP status register
        pub const TAMP_SR = @as(*volatile Mmio(32, packed struct {
            /// TAMP1 detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// TAMP1 input.
            TAMP1F: u1 = 0,
            /// TAMP2 detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// TAMP2 input.
            TAMP2F: u1 = 0,
            /// TAMP3 detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// TAMP3 input.
            TAMP3F: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            /// LSE monitoring tamper detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// internal tamper 3.
            ITAMP3F: u1 = 0,
            /// HSE monitoring tamper detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// internal tamper 4.
            ITAMP4F: u1 = 0,
            /// RTC calendar overflow tamper detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// internal tamper 5.
            ITAMP5F: u1 = 0,
            /// ST manufacturer readout tamper detection flag
            /// This flag is set by hardware when a tamper detection event is detected on the
            /// internal tamper 6.
            ITAMP6F: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x4000b034
        /// TAMP masked interrupt status register
        pub const TAMP_MISR = @as(*volatile Mmio(32, packed struct {
            /// TAMP1 interrupt masked flag
            /// This flag is set by hardware when the tamper 1 interrupt is raised.
            TAMP1MF: u1 = 0,
            /// TAMP2 interrupt masked flag
            /// This flag is set by hardware when the tamper 2 interrupt is raised.
            TAMP2MF: u1 = 0,
            /// TAMP3 interrupt masked flag
            /// This flag is set by hardware when the tamper 3 interrupt is raised.
            TAMP3MF: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            /// LSE monitoring tamper interrupt masked flag
            /// This flag is set by hardware when the internal tamper 3 interrupt is raised.
            ITAMP3MF: u1 = 0,
            /// HSE monitoring tamper interrupt masked flag
            /// This flag is set by hardware when the internal tamper 4 interrupt is raised.
            ITAMP4MF: u1 = 0,
            /// RTC calendar overflow tamper interrupt masked flag
            /// This flag is set by hardware when the internal tamper 5 interrupt is raised.
            ITAMP5MF: u1 = 0,
            /// ST manufacturer readout tamper interrupt masked flag
            /// This flag is set by hardware when the internal tamper 6 interrupt is raised.
            ITAMP6MF: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x4000b03c
        /// TAMP status clear register
        pub const TAMP_SCR = @as(*volatile Mmio(32, packed struct {
            /// Clear TAMP1 detection flag
            /// Writing 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
            CTAMP1F: u1 = 0,
            /// Clear TAMP2 detection flag
            /// Writing 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
            CTAMP2F: u1 = 0,
            /// Clear TAMP3 detection flag
            /// Writing 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
            CTAMP3F: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            /// Clear ITAMP3 detection flag
            /// Writing 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
            CITAMP3F: u1 = 0,
            /// Clear ITAMP4 detection flag
            /// Writing 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
            CITAMP4F: u1 = 0,
            /// Clear ITAMP5 detection flag
            /// Writing 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
            CITAMP5F: u1 = 0,
            /// Clear ITAMP6 detection flag
            /// Writing 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
            CITAMP6F: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x3c));

        /// address: 0x4000b100
        /// TAMP backup 0 register
        pub const TAMP_BKP0R = @as(*volatile Mmio(32, packed struct {
            /// The application can write or read data to and from these registers.
            /// They are powered-on by VBAT when VDD is switched off, so that they are not reset
            /// by System reset, and their contents remain valid when the device operates in
            /// low-power mode.
            /// In the default configuration this register is reset on a tamper detection event.
            /// It is forced to reset value as long as there is at least one internal or
            /// external tamper flag being set. This register is also reset when the readout
            /// protection (RDP) is disabled.
            BKP: u32 = 0,
        }), @ptrFromInt(base_address + 0x100));

        /// address: 0x4000b104
        /// TAMP backup 1 register
        pub const TAMP_BKP1R = @as(*volatile Mmio(32, packed struct {
            /// The application can write or read data to and from these registers.
            /// They are powered-on by VBAT when VDD is switched off, so that they are not reset
            /// by System reset, and their contents remain valid when the device operates in
            /// low-power mode.
            /// In the default configuration this register is reset on a tamper detection event.
            /// It is forced to reset value as long as there is at least one internal or
            /// external tamper flag being set. This register is also reset when the readout
            /// protection (RDP) is disabled.
            BKP: u32 = 0,
        }), @ptrFromInt(base_address + 0x104));

        /// address: 0x4000b108
        /// TAMP backup 2 register
        pub const TAMP_BKP2R = @as(*volatile Mmio(32, packed struct {
            /// The application can write or read data to and from these registers.
            /// They are powered-on by VBAT when VDD is switched off, so that they are not reset
            /// by System reset, and their contents remain valid when the device operates in
            /// low-power mode.
            /// In the default configuration this register is reset on a tamper detection event.
            /// It is forced to reset value as long as there is at least one internal or
            /// external tamper flag being set. This register is also reset when the readout
            /// protection (RDP) is disabled.
            BKP: u32 = 0,
        }), @ptrFromInt(base_address + 0x108));

        /// address: 0x4000b10c
        /// TAMP backup 3 register
        pub const TAMP_BKP3R = @as(*volatile Mmio(32, packed struct {
            /// The application can write or read data to and from these registers.
            /// They are powered-on by VBAT when VDD is switched off, so that they are not reset
            /// by System reset, and their contents remain valid when the device operates in
            /// low-power mode.
            /// In the default configuration this register is reset on a tamper detection event.
            /// It is forced to reset value as long as there is at least one internal or
            /// external tamper flag being set. This register is also reset when the readout
            /// protection (RDP) is disabled.
            BKP: u32 = 0,
        }), @ptrFromInt(base_address + 0x10c));

        /// address: 0x4000b110
        /// TAMP backup 4 register
        pub const TAMP_BKP4R = @as(*volatile Mmio(32, packed struct {
            /// The application can write or read data to and from these registers.
            /// They are powered-on by VBAT when VDD is switched off, so that they are not reset
            /// by System reset, and their contents remain valid when the device operates in
            /// low-power mode.
            /// In the default configuration this register is reset on a tamper detection event.
            /// It is forced to reset value as long as there is at least one internal or
            /// external tamper flag being set. This register is also reset when the readout
            /// protection (RDP) is disabled.
            BKP: u32 = 0,
        }), @ptrFromInt(base_address + 0x110));
    };

    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1 = 0,
            /// TX Interrupt enable
            TXIE: u1 = 0,
            /// RX Interrupt enable
            RXIE: u1 = 0,
            /// Address match interrupt enable (slave only)
            ADDRIE: u1 = 0,
            /// Not acknowledge received interrupt enable
            NACKIE: u1 = 0,
            /// STOP detection Interrupt enable
            STOPIE: u1 = 0,
            /// Transfer Complete interrupt enable
            TCIE: u1 = 0,
            /// Error interrupts enable
            ERRIE: u1 = 0,
            /// Digital noise filter
            DNF: u4 = 0,
            /// Analog noise filter OFF
            ANFOFF: u1 = 0,
            _reserved13: u1 = 0,
            /// DMA transmission requests enable
            TXDMAEN: u1 = 0,
            /// DMA reception requests enable
            RXDMAEN: u1 = 0,
            /// Slave byte control
            SBC: u1 = 0,
            /// Clock stretching disable
            NOSTRETCH: u1 = 0,
            /// Wakeup from STOP enable
            WUPEN: u1 = 0,
            /// General call enable
            GCEN: u1 = 0,
            /// SMBus Host address enable
            SMBHEN: u1 = 0,
            /// SMBus Device Default address enable
            SMBDEN: u1 = 0,
            /// SMBUS alert enable
            ALERTEN: u1 = 0,
            /// PEC enable
            PECEN: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Slave address bit (master mode)
            SADD: u10 = 0,
            /// Transfer direction (master mode)
            RD_WRN: u1 = 0,
            /// 10-bit addressing mode (master mode)
            ADD10: u1 = 0,
            /// 10-bit address header only read direction (master receiver mode)
            HEAD10R: u1 = 0,
            /// Start generation
            START: u1 = 0,
            /// Stop generation (master mode)
            STOP: u1 = 0,
            /// NACK generation (slave mode)
            NACK: u1 = 0,
            /// Number of bytes
            NBYTES: u8 = 0,
            /// NBYTES reload mode
            RELOAD: u1 = 0,
            /// Automatic end mode (master mode)
            AUTOEND: u1 = 0,
            /// Packet error checking byte
            PECBYTE: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @as(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1 = 0,
            /// Interface address
            OA1_7_1: u7 = 0,
            /// Interface address
            OA1_8_9: u2 = 0,
            /// Own Address 1 10-bit mode
            OA1MODE: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Own Address 1 enable
            OA1EN: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            /// Interface address
            OA2: u7 = 0,
            /// Own Address 2 masks
            OA2MSK: u3 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Own Address 2 enable
            OA2EN: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @as(*volatile Mmio(32, packed struct {
            /// SCL low period (master mode)
            SCLL: u8 = 0,
            /// SCL high period (master mode)
            SCLH: u8 = 0,
            /// Data hold time
            SDADEL: u4 = 0,
            /// Data setup time
            SCLDEL: u4 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            /// Timing prescaler
            PRESC: u4 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @as(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12 = 0,
            /// Idle clock timeout detection
            TIDLE: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Clock timeout enable
            TIMOUTEN: u1 = 0,
            /// Bus timeout B
            TIMEOUTB: u12 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// Extended clock timeout enable
            TEXTEN: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @as(*volatile Mmio(32, packed struct {
            /// Transmit data register empty (transmitters)
            TXE: u1 = 1,
            /// Transmit interrupt status (transmitters)
            TXIS: u1 = 0,
            /// Receive data register not empty (receivers)
            RXNE: u1 = 0,
            /// Address matched (slave mode)
            ADDR: u1 = 0,
            /// Not acknowledge received flag
            NACKF: u1 = 0,
            /// Stop detection flag
            STOPF: u1 = 0,
            /// Transfer Complete (master mode)
            TC: u1 = 0,
            /// Transfer Complete Reload
            TCR: u1 = 0,
            /// Bus error
            BERR: u1 = 0,
            /// Arbitration lost
            ARLO: u1 = 0,
            /// Overrun/Underrun (slave mode)
            OVR: u1 = 0,
            /// PEC Error in reception
            PECERR: u1 = 0,
            /// Timeout or t_low detection flag
            TIMEOUT: u1 = 0,
            /// SMBus alert
            ALERT: u1 = 0,
            _reserved14: u1 = 0,
            /// Bus busy
            BUSY: u1 = 0,
            /// Transfer direction (Slave mode)
            DIR: u1 = 0,
            /// Address match code (Slave mode)
            ADDCODE: u7 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            /// Address Matched flag clear
            ADDRCF: u1 = 0,
            /// Not Acknowledge flag clear
            NACKCF: u1 = 0,
            /// Stop detection flag clear
            STOPCF: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Bus error flag clear
            BERRCF: u1 = 0,
            /// Arbitration lost flag clear
            ARLOCF: u1 = 0,
            /// Overrun/Underrun flag clear
            OVRCF: u1 = 0,
            /// PEC Error flag clear
            PECCF: u1 = 0,
            /// Timeout detection flag clear
            TIMOUTCF: u1 = 0,
            /// Alert flag clear
            ALERTCF: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @as(*volatile Mmio(32, packed struct {
            /// Packet error checking register
            PEC: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @as(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @as(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1 = 0,
            /// TX Interrupt enable
            TXIE: u1 = 0,
            /// RX Interrupt enable
            RXIE: u1 = 0,
            /// Address match interrupt enable (slave only)
            ADDRIE: u1 = 0,
            /// Not acknowledge received interrupt enable
            NACKIE: u1 = 0,
            /// STOP detection Interrupt enable
            STOPIE: u1 = 0,
            /// Transfer Complete interrupt enable
            TCIE: u1 = 0,
            /// Error interrupts enable
            ERRIE: u1 = 0,
            /// Digital noise filter
            DNF: u4 = 0,
            /// Analog noise filter OFF
            ANFOFF: u1 = 0,
            _reserved13: u1 = 0,
            /// DMA transmission requests enable
            TXDMAEN: u1 = 0,
            /// DMA reception requests enable
            RXDMAEN: u1 = 0,
            /// Slave byte control
            SBC: u1 = 0,
            /// Clock stretching disable
            NOSTRETCH: u1 = 0,
            /// Wakeup from STOP enable
            WUPEN: u1 = 0,
            /// General call enable
            GCEN: u1 = 0,
            /// SMBus Host address enable
            SMBHEN: u1 = 0,
            /// SMBus Device Default address enable
            SMBDEN: u1 = 0,
            /// SMBUS alert enable
            ALERTEN: u1 = 0,
            /// PEC enable
            PECEN: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            /// Slave address bit (master mode)
            SADD: u10 = 0,
            /// Transfer direction (master mode)
            RD_WRN: u1 = 0,
            /// 10-bit addressing mode (master mode)
            ADD10: u1 = 0,
            /// 10-bit address header only read direction (master receiver mode)
            HEAD10R: u1 = 0,
            /// Start generation
            START: u1 = 0,
            /// Stop generation (master mode)
            STOP: u1 = 0,
            /// NACK generation (slave mode)
            NACK: u1 = 0,
            /// Number of bytes
            NBYTES: u8 = 0,
            /// NBYTES reload mode
            RELOAD: u1 = 0,
            /// Automatic end mode (master mode)
            AUTOEND: u1 = 0,
            /// Packet error checking byte
            PECBYTE: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @as(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1 = 0,
            /// Interface address
            OA1_7_1: u7 = 0,
            /// Interface address
            OA1_8_9: u2 = 0,
            /// Own Address 1 10-bit mode
            OA1MODE: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Own Address 1 enable
            OA1EN: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            /// Interface address
            OA2: u7 = 0,
            /// Own Address 2 masks
            OA2MSK: u3 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Own Address 2 enable
            OA2EN: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @as(*volatile Mmio(32, packed struct {
            /// SCL low period (master mode)
            SCLL: u8 = 0,
            /// SCL high period (master mode)
            SCLH: u8 = 0,
            /// Data hold time
            SDADEL: u4 = 0,
            /// Data setup time
            SCLDEL: u4 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            /// Timing prescaler
            PRESC: u4 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @as(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12 = 0,
            /// Idle clock timeout detection
            TIDLE: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// Clock timeout enable
            TIMOUTEN: u1 = 0,
            /// Bus timeout B
            TIMEOUTB: u12 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// Extended clock timeout enable
            TEXTEN: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @as(*volatile Mmio(32, packed struct {
            /// Transmit data register empty (transmitters)
            TXE: u1 = 1,
            /// Transmit interrupt status (transmitters)
            TXIS: u1 = 0,
            /// Receive data register not empty (receivers)
            RXNE: u1 = 0,
            /// Address matched (slave mode)
            ADDR: u1 = 0,
            /// Not acknowledge received flag
            NACKF: u1 = 0,
            /// Stop detection flag
            STOPF: u1 = 0,
            /// Transfer Complete (master mode)
            TC: u1 = 0,
            /// Transfer Complete Reload
            TCR: u1 = 0,
            /// Bus error
            BERR: u1 = 0,
            /// Arbitration lost
            ARLO: u1 = 0,
            /// Overrun/Underrun (slave mode)
            OVR: u1 = 0,
            /// PEC Error in reception
            PECERR: u1 = 0,
            /// Timeout or t_low detection flag
            TIMEOUT: u1 = 0,
            /// SMBus alert
            ALERT: u1 = 0,
            _reserved14: u1 = 0,
            /// Bus busy
            BUSY: u1 = 0,
            /// Transfer direction (Slave mode)
            DIR: u1 = 0,
            /// Address match code (Slave mode)
            ADDCODE: u7 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            /// Address Matched flag clear
            ADDRCF: u1 = 0,
            /// Not Acknowledge flag clear
            NACKCF: u1 = 0,
            /// Stop detection flag clear
            STOPCF: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Bus error flag clear
            BERRCF: u1 = 0,
            /// Arbitration lost flag clear
            ARLOCF: u1 = 0,
            /// Overrun/Underrun flag clear
            OVRCF: u1 = 0,
            /// PEC Error flag clear
            PECCF: u1 = 0,
            /// Timeout detection flag clear
            TIMOUTCF: u1 = 0,
            /// Alert flag clear
            ALERTCF: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @as(*volatile Mmio(32, packed struct {
            /// Packet error checking register
            PEC: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @as(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @as(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// RTC time register
        pub const RTC_TR = @as(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4 = 0,
            /// Second tens in BCD format
            ST: u3 = 0,
            _reserved7: u1 = 0,
            /// Minute units in BCD format
            MNU: u4 = 0,
            /// Minute tens in BCD format
            MNT: u3 = 0,
            _reserved15: u1 = 0,
            /// Hour units in BCD format
            HU: u4 = 0,
            /// Hour tens in BCD format
            HT: u2 = 0,
            /// AM/PM notation
            PM: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40002804
        /// RTC date register
        pub const RTC_DR = @as(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4 = 1,
            /// Date tens in BCD format
            DT: u2 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Month units in BCD format
            MU: u4 = 1,
            /// Month tens in BCD format
            MT: u1 = 0,
            /// Week day units
            /// ...
            WDU: u3 = 1,
            /// Year units in BCD format
            YU: u4 = 0,
            /// Year tens in BCD format
            YT: u4 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40002808
        /// RTC sub second register
        pub const RTC_SSR = @as(*volatile Mmio(32, packed struct {
            /// Sub second value
            /// SS[15:0] is the value in the synchronous prescaler counter. The fraction of a
            /// second is given by the formula below:
            /// Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1)
            /// Note: SS can be larger than PREDIV_S only after a shift operation. In that case,
            /// the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
            SS: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000280c
        /// RTC initialization control and status register
        pub const RTC_ICSR = @as(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            /// This bit is set by hardware when alarm A values can be changed, after the ALRAE
            /// bit has been set to 0 in RTC_CR.
            /// It is cleared by hardware in initialization mode.
            ALRAWF: u1 = 1,
            /// Alarm B write flag
            /// This bit is set by hardware when alarm B values can be changed, after the ALRBE
            /// bit has been set to 0 in RTC_CR.
            /// It is cleared by hardware in initialization mode.
            ALRBWF: u1 = 1,
            /// Wakeup timer write flag
            /// This bit is set by hardware when WUT value can be changed, after the WUTE bit
            /// has been set to 0 in RTC_CR.
            /// It is cleared by hardware in initialization mode.
            WUTWF: u1 = 1,
            /// Shift operation pending
            /// This flag is set by hardware as soon as a shift operation is initiated by a
            /// write to the RTC_SHIFTR register. It is cleared by hardware when the
            /// corresponding shift operation has been executed. Writing to the SHPF bit has no
            /// effect.
            SHPF: u1 = 0,
            /// Initialization status flag
            /// This bit is set by hardware when the calendar year field is different from 0
            /// (Backup domain reset state).
            INITS: u1 = 0,
            /// Registers synchronization flag
            /// This bit is set by hardware each time the calendar registers are copied into the
            /// shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware
            /// in initialization mode, while a shift operation is pending (SHPF = 1), or when
            /// in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by
            /// software.
            /// It is cleared either by software or by hardware in initialization mode.
            RSF: u1 = 0,
            /// Initialization flag
            /// When this bit is set to 1, the RTC is in initialization state, and the time,
            /// date and prescaler registers can be updated.
            INITF: u1 = 0,
            /// Initialization mode
            INIT: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Recalibration pending Flag
            /// The RECALPF status flag is automatically set to 1 when software writes to the
            /// RTC_CALR register, indicating that the RTC_CALR register is blocked. When the
            /// new calibration settings are taken into account, this bit returns to 0. Refer to
            /// .
            RECALPF: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40002810
        /// RTC prescaler register
        pub const RTC_PRER = @as(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler factor
            /// This is the synchronous division factor:
            /// ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
            PREDIV_S: u15 = 255,
            _reserved15: u1 = 0,
            /// Asynchronous prescaler factor
            /// This is the asynchronous division factor:
            /// ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
            PREDIV_A: u7 = 127,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40002814
        /// RTC wakeup timer register
        pub const RTC_WUTR = @as(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value bits
            /// When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every
            /// (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0]
            /// bits of the RTC_CR register.
            /// When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively
            /// becomes WUT[16] the most-significant bit to be reloaded into the timer.
            /// The first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after
            /// WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is
            /// forbidden.
            WUT: u16 = 65535,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40002818
        /// control register
        pub const RTC_CR = @as(*volatile Mmio(32, packed struct {
            /// ck_wut wakeup clock selection
            /// 10x: ck_spre (usually 1Hz) clock is selected
            /// 11x: ck_spre (usually 1Hz) clock is selected and 216is added to the WUT counter
            /// value
            WUCKSEL: u3 = 0,
            /// Timestamp event active edge
            /// TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
            TSEDGE: u1 = 0,
            /// RTC_REFIN reference clock detection enable (50 or 60Hz)
            /// Note: PREDIV_S must be 0x00FF.
            REFCKON: u1 = 0,
            /// Bypass the shadow registers
            /// Note: If the frequency of the APB1 clock is less than seven times the frequency
            /// of RTCCLK, BYPSHAD must be set to 1.
            BYPSHAD: u1 = 0,
            /// Hour format
            FMT: u1 = 0,
            _reserved7: u1 = 0,
            /// Alarm A enable
            ALRAE: u1 = 0,
            /// Alarm B enable
            ALRBE: u1 = 0,
            /// Wakeup timer enable
            /// Note: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it
            /// again.
            WUTE: u1 = 0,
            /// timestamp enable
            TSE: u1 = 0,
            /// Alarm A interrupt enable
            ALRAIE: u1 = 0,
            /// Alarm B interrupt enable
            ALRBIE: u1 = 0,
            /// Wakeup timer interrupt enable
            WUTIE: u1 = 0,
            /// Timestamp interrupt enable
            TSIE: u1 = 0,
            /// Add 1 hour (summer time change)
            /// When this bit is set outside initialization mode, 1 hour is added to the
            /// calendar time. This bit is always read as 0.
            ADD1H: u1 = 0,
            /// Subtract 1 hour (winter time change)
            /// When this bit is set outside initialization mode, 1 hour is subtracted to the
            /// calendar time if the current hour is not 0. This bit is always read as 0.
            /// Setting this bit has no effect when current hour is 0.
            SUB1H: u1 = 0,
            /// Backup
            /// This bit can be written by the user to memorize whether the daylight saving time
            /// change has been performed or not.
            BKP: u1 = 0,
            /// Calibration output selection
            /// When COE = 1, this bit selects which signal is output on CALIB.
            /// These frequencies are valid for RTCCLK at 32.768kHz and prescalers at their
            /// default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
            COSEL: u1 = 0,
            /// Output polarity
            /// This bit is used to configure the polarity of TAMPALRM output.
            POL: u1 = 0,
            /// Output selection
            /// These bits are used to select the flag to be routed to TAMPALRM output.
            OSEL: u2 = 0,
            /// Calibration output enable
            /// This bit enables the CALIB output
            COE: u1 = 0,
            /// timestamp on internal event enable
            ITSE: u1 = 0,
            /// Activate timestamp on tamper detection event
            /// TAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set
            /// after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended
            /// to disable the tamper interrupts in order to avoid servicing 2 interrupts.
            TAMPTS: u1 = 0,
            /// Tamper detection output enable on TAMPALRM
            TAMPOE: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            /// TAMPALRM pull-up enable
            TAMPALRM_PU: u1 = 0,
            /// TAMPALRM output type
            TAMPALRM_TYPE: u1 = 0,
            /// RTC_OUT2 output enable
            /// Setting this bit allows to remap the RTC outputs on RTC_OUT2 as follows:
            /// OUT2EN = 0: RTC output 2 disable
            /// If OSEL â  00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1
            /// If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1
            /// OUT2EN = 1: RTC output 2 enable
            /// If (OSEL â  00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2
            /// If OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2
            /// If (OSELâ  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and
            /// TAMPALRM is output on RTC_OUT1.
            OUT2EN: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40002824
        /// write protection register
        pub const RTC_WPR = @as(*volatile Mmio(32, packed struct {
            /// Write protection key
            /// This byte is written by software.
            /// Reading this byte always returns 0x00.
            /// Refer to for a description of how to unlock RTC register write protection.
            KEY: u8 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40002828
        /// RTC calibration register
        pub const RTC_CALR = @as(*volatile Mmio(32, packed struct {
            /// Calibration minus
            /// The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK
            /// pulses (32 seconds if the input frequency is 32768Hz). This decreases the
            /// frequency of the calendar with a resolution of 0.9537ppm.
            /// To increase the frequency of the calendar, this feature should be used in
            /// conjunction with CALP. See .
            CALM: u9 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            /// Use a 16-second calibration cycle period
            /// When CALW16 is set to 1, the 16-second calibration cycle period is selected.
            /// This bit must not be set to 1 if CALW8 = 1.
            /// Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
            CALW16: u1 = 0,
            /// Use an 8-second calibration cycle period
            /// When CALW8 is set to 1, the 8-second calibration cycle period is selected.
            /// Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
            CALW8: u1 = 0,
            /// Increase frequency of RTC by 488.5ppm
            /// This feature is intended to be used in conjunction with CALM, which lowers the
            /// frequency of the calendar with a fine resolution. if the input frequency is
            /// 32768Hz, the number of RTCCLK pulses added during a 32-second window is
            /// calculated as follows: (512 Ã CALP) - CALM.
            /// Refer to .
            CALP: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000282c
        /// RTC shift control register
        pub const RTC_SHIFTR = @as(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a second
            /// These bits are write only and is always read as zero. Writing to this bit has no
            /// effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
            /// The value which is written to SUBFS is added to the synchronous prescaler
            /// counter. Since this counter counts down, this operation effectively subtracts
            /// from (delays) the clock by:
            /// Delay (seconds) = SUBFS / (PREDIV_S + 1)
            /// A fraction of a second can effectively be added to the clock (advancing the
            /// clock) when the ADD1S function is used in conjunction with SUBFS, effectively
            /// advancing the clock by:
            /// Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).
            /// Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until
            /// RSF = 1 to be sure that the shadow registers have been updated with the shifted
            /// time.
            SUBFS: u15 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// Add one second
            /// This bit is write only and is always read as zero. Writing to this bit has no
            /// effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).
            /// This function is intended to be used with SUBFS (see description below) in order
            /// to effectively add a fraction of a second to the clock in an atomic operation.
            ADD1S: u1 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40002830
        /// RTC timestamp time register
        pub const RTC_TSTR = @as(*volatile Mmio(32, packed struct {
            /// Second units in BCD format.
            SU: u4 = 0,
            /// Second tens in BCD format.
            ST: u3 = 0,
            _reserved7: u1 = 0,
            /// Minute units in BCD format.
            MNU: u4 = 0,
            /// Minute tens in BCD format.
            MNT: u3 = 0,
            _reserved15: u1 = 0,
            /// Hour units in BCD format.
            HU: u4 = 0,
            /// Hour tens in BCD format.
            HT: u2 = 0,
            /// AM/PM notation
            PM: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x30));

        /// address: 0x40002834
        /// RTC timestamp date register
        pub const RTC_TSDR = @as(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4 = 0,
            /// Date tens in BCD format
            DT: u2 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// Month units in BCD format
            MU: u4 = 0,
            /// Month tens in BCD format
            MT: u1 = 0,
            /// Week day units
            WDU: u3 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x40002838
        /// RTC timestamp sub second register
        pub const RTC_TSSSR = @as(*volatile Mmio(32, packed struct {
            /// Sub second value
            /// SS[15:0] is the value of the synchronous prescaler counter when the timestamp
            /// event occurred.
            SS: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x38));

        /// address: 0x40002840
        /// RTC alarm A register
        pub const RTC_ALRMAR = @as(*volatile Mmio(32, packed struct {
            /// Second units in BCD format.
            SU: u4 = 0,
            /// Second tens in BCD format.
            ST: u3 = 0,
            /// Alarm A seconds mask
            MSK1: u1 = 0,
            /// Minute units in BCD format
            MNU: u4 = 0,
            /// Minute tens in BCD format
            MNT: u3 = 0,
            /// Alarm A minutes mask
            MSK2: u1 = 0,
            /// Hour units in BCD format
            HU: u4 = 0,
            /// Hour tens in BCD format
            HT: u2 = 0,
            /// AM/PM notation
            PM: u1 = 0,
            /// Alarm A hours mask
            MSK3: u1 = 0,
            /// Date units or day in BCD format
            DU: u4 = 0,
            /// Date tens in BCD format
            DT: u2 = 0,
            /// Week day selection
            WDSEL: u1 = 0,
            /// Alarm A date mask
            MSK4: u1 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x40002844
        /// RTC alarm A sub second register
        pub const RTC_ALRMASSR = @as(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            /// This value is compared with the contents of the synchronous prescaler counter to
            /// determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
            SS: u15 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Mask the most-significant bits starting at this bit
            /// 2: SS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared.
            /// 3: SS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared.
            /// ...
            /// 12: SS[14:12] are don't care in alarm A comparison. SS[11:0] are compared.
            /// 13: SS[14:13] are don't care in alarm A comparison. SS[12:0] are compared.
            /// 14: SS[14] is don't care in alarm A comparison. SS[13:0] are compared.
            /// 15: All 15 SS bits are compared and must match to activate alarm.
            /// The overflow bits of the synchronous counter (bits 15) is never compared. This
            /// bit can be different from 0 only after a shift operation.
            /// Note: The overflow bits of the synchronous counter (bits 15) is never compared.
            /// This bit can be different from 0 only after a shift operation.
            MASKSS: u4 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x44));

        /// address: 0x40002848
        /// RTC alarm B register
        pub const RTC_ALRMBR = @as(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4 = 0,
            /// Second tens in BCD format
            ST: u3 = 0,
            /// Alarm B seconds mask
            MSK1: u1 = 0,
            /// Minute units in BCD format
            MNU: u4 = 0,
            /// Minute tens in BCD format
            MNT: u3 = 0,
            /// Alarm B minutes mask
            MSK2: u1 = 0,
            /// Hour units in BCD format
            HU: u4 = 0,
            /// Hour tens in BCD format
            HT: u2 = 0,
            /// AM/PM notation
            PM: u1 = 0,
            /// Alarm B hours mask
            MSK3: u1 = 0,
            /// Date units or day in BCD format
            DU: u4 = 0,
            /// Date tens in BCD format
            DT: u2 = 0,
            /// Week day selection
            WDSEL: u1 = 0,
            /// Alarm B date mask
            MSK4: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4000284c
        /// RTC alarm B sub second register
        pub const RTC_ALRMBSSR = @as(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            /// This value is compared with the contents of the synchronous prescaler counter to
            /// determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are
            /// compared.
            SS: u15 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Mask the most-significant bits starting at this bit
            /// ...
            /// The overflow bits of the synchronous counter (bits 15) is never compared. This
            /// bit can be different from 0 only after a shift operation.
            MASKSS: u4 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40002850
        /// RTC status register
        pub const RTC_SR = @as(*volatile Mmio(32, packed struct {
            /// Alarm A flag
            /// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR)
            /// match the alarm A register (RTC_ALRMAR).
            ALRAF: u1 = 0,
            /// Alarm B flag
            /// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR)
            /// match the alarm B register (RTC_ALRMBR).
            ALRBF: u1 = 0,
            /// Wakeup timer flag
            /// This flag is set by hardware when the wakeup auto-reload counter reaches 0.
            /// This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is
            /// set to 1 again.
            WUTF: u1 = 0,
            /// Timestamp flag
            /// This flag is set by hardware when a timestamp event occurs.
            /// If ITSF flag is set, TSF must be cleared together with ITSF.
            TSF: u1 = 0,
            /// Timestamp overflow flag
            /// This flag is set by hardware when a timestamp event occurs while TSF is already
            /// set.
            /// It is recommended to check and then clear TSOVF only after clearing the TSF bit.
            /// Otherwise, an overflow might not be noticed if a timestamp event occurs
            /// immediately before the TSF bit is cleared.
            TSOVF: u1 = 0,
            /// Internal timestamp flag
            /// This flag is set by hardware when a timestamp on the internal event occurs.
            ITSF: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));

        /// address: 0x40002854
        /// RTC masked interrupt status register
        pub const RTC_MISR = @as(*volatile Mmio(32, packed struct {
            /// Alarm A masked flag
            /// This flag is set by hardware when the alarm A interrupt occurs.
            ALRAMF: u1 = 0,
            /// Alarm B masked flag
            /// This flag is set by hardware when the alarm B interrupt occurs.
            ALRBMF: u1 = 0,
            /// Wakeup timer masked flag
            /// This flag is set by hardware when the wakeup timer interrupt occurs.
            /// This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is
            /// set to 1 again.
            WUTMF: u1 = 0,
            /// Timestamp masked flag
            /// This flag is set by hardware when a timestamp interrupt occurs.
            /// If ITSF flag is set, TSF must be cleared together with ITSF.
            TSMF: u1 = 0,
            /// Timestamp overflow masked flag
            /// This flag is set by hardware when a timestamp interrupt occurs while TSMF is
            /// already set.
            /// It is recommended to check and then clear TSOVF only after clearing the TSF bit.
            /// Otherwise, an overflow might not be noticed if a timestamp event occurs
            /// immediately before the TSF bit is cleared.
            TSOVMF: u1 = 0,
            /// Internal timestamp masked flag
            /// This flag is set by hardware when a timestamp on the internal event occurs and
            /// timestampinterrupt is raised.
            ITSMF: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x54));

        /// address: 0x4000285c
        /// RTC status clear register
        pub const RTC_SCR = @as(*volatile Mmio(32, packed struct {
            /// Clear alarm A flag
            /// Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
            CALRAF: u1 = 0,
            /// Clear alarm B flag
            /// Writing 1 in this bit clears the ALRBF bit in the RTC_SR register.
            CALRBF: u1 = 0,
            /// Clear wakeup timer flag
            /// Writing 1 in this bit clears the WUTF bit in the RTC_SR register.
            CWUTF: u1 = 0,
            /// Clear timestamp flag
            /// Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.
            /// If ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and
            /// CITSF.
            CTSF: u1 = 0,
            /// Clear timestamp overflow flag
            /// Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.
            /// It is recommended to check and then clear TSOVF only after clearing the TSF bit.
            /// Otherwise, an overflow might not be noticed if a timestamp event occurs
            /// immediately before the TSF bit is cleared.
            CTSOVF: u1 = 0,
            /// Clear internal timestamp flag
            /// Writing 1 in this bit clears the ITSF bit in the RTC_SR register.
            CITSF: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x5c));
    };

    /// General purpose timers
    pub const TIM14 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x4000200c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40002010
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40002014
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40002018
        /// capture/compare mode register 1 (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2 = 0,
            /// OC1FE
            OC1FE: u1 = 0,
            /// OC1PE
            OC1PE: u1 = 0,
            /// OC1M
            OC1M: u3 = 0,
            /// OC1CE
            OC1CE: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Output Compare 1 mode - bit 3
            OC1M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40002018
        /// capture/compare mode register 1 (input mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Input capture 1 prescaler
            ICPCS: u2 = 0,
            /// Input capture 1 filter
            IC1F: u4 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40002020
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            _reserved2: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40002024
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// low counter value
            CNT: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            /// UIF Copy
            UIFCPY: u1 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40002028
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000202c
        /// auto-reload register
        pub const ARR = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40002034
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x34));

        /// address: 0x40002068
        /// TIM timer input selection register
        pub const TISEL = @as(*volatile MmioInt(32, u4), @ptrFromInt(base_address + 0x68));
    };

    /// General-purpose-timers
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            /// Direction
            DIR: u1 = 0,
            /// Center-aligned mode selection
            CMS: u2 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            /// Capture/compare DMA selection
            CCDS: u1 = 0,
            /// Master mode selection
            MMS: u3 = 0,
            /// TI1 selection
            TI1S: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @as(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3 = 0,
            /// OCREF clear selection
            OCCS: u1 = 0,
            /// Trigger selection
            TS: u3 = 0,
            /// Master/Slave mode
            MSM: u1 = 0,
            /// External trigger filter
            ETF: u4 = 0,
            /// External trigger prescaler
            ETPS: u2 = 0,
            /// External clock enable
            ECE: u1 = 0,
            /// External trigger polarity
            ETP: u1 = 0,
            /// Slave mode selection - bit 3
            SMS_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            /// Trigger selection
            TS_4_3: u2 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            /// Capture/Compare 2 interrupt enable
            CC2IE: u1 = 0,
            /// Capture/Compare 3 interrupt enable
            CC3IE: u1 = 0,
            /// Capture/Compare 4 interrupt enable
            CC4IE: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger interrupt enable
            TIE: u1 = 0,
            _reserved7: u1 = 0,
            /// Update DMA request enable
            UDE: u1 = 0,
            /// Capture/Compare 1 DMA request enable
            CC1DE: u1 = 0,
            /// Capture/Compare 2 DMA request enable
            CC2DE: u1 = 0,
            /// Capture/Compare 3 DMA request enable
            CC3DE: u1 = 0,
            /// Capture/Compare 4 DMA request enable
            CC4DE: u1 = 0,
            _reserved13: u1 = 0,
            /// Trigger DMA request enable
            TDE: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40000010
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            /// Capture/Compare 2 interrupt flag
            CC2IF: u1 = 0,
            /// Capture/Compare 3 interrupt flag
            CC3IF: u1 = 0,
            /// Capture/Compare 4 interrupt flag
            CC4IF: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger interrupt flag
            TIF: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            /// Capture/compare 2 overcapture flag
            CC2OF: u1 = 0,
            /// Capture/Compare 3 overcapture flag
            CC3OF: u1 = 0,
            /// Capture/Compare 4 overcapture flag
            CC4OF: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            /// Capture/compare 2 generation
            CC2G: u1 = 0,
            /// Capture/compare 3 generation
            CC3G: u1 = 0,
            /// Capture/compare 4 generation
            CC4G: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger generation
            TG: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40000018
        /// capture/compare mode register 1 (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output compare 1 mode
            OC1M: u3 = 0,
            /// Output compare 1 clear enable
            OC1CE: u1 = 0,
            /// Capture/Compare 2 selection
            CC2S: u2 = 0,
            /// Output compare 2 fast enable
            OC2FE: u1 = 0,
            /// Output compare 2 preload enable
            OC2PE: u1 = 0,
            /// Output compare 2 mode
            OC2M: u3 = 0,
            /// Output compare 2 clear enable
            OC2CE: u1 = 0,
            /// Output Compare 1 mode - bit 3
            OC1M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 2 mode - bit 3
            OC2M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40000018
        /// capture/compare mode register 1 (input mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Input capture 1 prescaler
            IC1PSC: u2 = 0,
            /// Input capture 1 filter
            IC1F: u4 = 0,
            /// Capture/compare 2 selection
            CC2S: u2 = 0,
            /// Input capture 2 prescaler
            IC2PSC: u2 = 0,
            /// Input capture 2 filter
            IC2F: u4 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output mode)
        pub const CCMR2_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Output compare 3 fast enable
            OC3FE: u1 = 0,
            /// Output compare 3 preload enable
            OC3PE: u1 = 0,
            /// Output compare 3 mode
            OC3M: u3 = 0,
            /// Output compare 3 clear enable
            OC3CE: u1 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Output compare 4 fast enable
            OC4FE: u1 = 0,
            /// Output compare 4 preload enable
            OC4PE: u1 = 0,
            /// Output compare 4 mode
            OC4M: u3 = 0,
            /// Output compare 4 clear enable
            OC4CE: u1 = 0,
            /// Output Compare 3 mode - bit 3
            OC3M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 4 mode - bit 3
            OC4M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input mode)
        pub const CCMR2_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Input capture 3 prescaler
            IC3PSC: u2 = 0,
            /// Input capture 3 filter
            IC3F: u4 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Input capture 4 prescaler
            IC4PSC: u2 = 0,
            /// Input capture 4 filter
            IC4F: u4 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40000020
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            _reserved2: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            /// Capture/Compare 2 output enable
            CC2E: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2P: u1 = 0,
            _reserved6: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2NP: u1 = 0,
            /// Capture/Compare 3 output enable
            CC3E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3P: u1 = 0,
            _reserved10: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3NP: u1 = 0,
            /// Capture/Compare 4 output enable
            CC4E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC4P: u1 = 0,
            _reserved14: u1 = 0,
            /// Capture/Compare 4 output Polarity
            CC4NP: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40000024
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16 = 0,
            /// High counter value (TIM2 only)
            CNT_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @as(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16 = 0,
            /// High Auto-reload value (TIM2 only)
            ARR_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1 value
            CCR1_L: u16 = 0,
            /// High Capture/Compare 1 value (TIM2 only)
            CCR1_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2 value
            CCR2_L: u16 = 0,
            /// High Capture/Compare 2 value (TIM2 only)
            CCR2_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x38));

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16 = 0,
            /// High Capture/Compare value (TIM2 only)
            CCR3_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16 = 0,
            /// High Capture/Compare value (TIM2 only)
            CCR4_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @as(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// DMA burst length
            DBL: u5 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @as(*volatile Mmio(32, packed struct {
            /// DMA register for burst accesses
            DMAB: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40000050
        /// TIM option register
        pub const OR1 = @as(*volatile Mmio(32, packed struct {
            /// IOCREF_CLR
            IOCREF_CLR: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));

        /// address: 0x40000060
        /// TIM alternate function option register 1
        pub const AF1 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// External trigger source selection
            ETRSEL: u4 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40000068
        /// TIM alternate function option register 1
        pub const TISEL = @as(*volatile Mmio(32, packed struct {
            /// TI1SEL
            TI1SEL: u4 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// TI2SEL
            TI2SEL: u4 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x68));
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @as(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1 = 0,
            /// Update disable
            UDIS: u1 = 0,
            /// Update request source
            URS: u1 = 0,
            /// One-pulse mode
            OPM: u1 = 0,
            /// Direction
            DIR: u1 = 0,
            /// Center-aligned mode selection
            CMS: u2 = 0,
            /// Auto-reload preload enable
            ARPE: u1 = 0,
            /// Clock division
            CKD: u2 = 0,
            _reserved10: u1 = 0,
            /// UIF status bit remapping
            UIFREMAP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            /// Capture/compare DMA selection
            CCDS: u1 = 0,
            /// Master mode selection
            MMS: u3 = 0,
            /// TI1 selection
            TI1S: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @as(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3 = 0,
            /// OCREF clear selection
            OCCS: u1 = 0,
            /// Trigger selection
            TS: u3 = 0,
            /// Master/Slave mode
            MSM: u1 = 0,
            /// External trigger filter
            ETF: u4 = 0,
            /// External trigger prescaler
            ETPS: u2 = 0,
            /// External clock enable
            ECE: u1 = 0,
            /// External trigger polarity
            ETP: u1 = 0,
            /// Slave mode selection - bit 3
            SMS_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            /// Trigger selection
            TS_4_3: u2 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1 = 0,
            /// Capture/Compare 1 interrupt enable
            CC1IE: u1 = 0,
            /// Capture/Compare 2 interrupt enable
            CC2IE: u1 = 0,
            /// Capture/Compare 3 interrupt enable
            CC3IE: u1 = 0,
            /// Capture/Compare 4 interrupt enable
            CC4IE: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger interrupt enable
            TIE: u1 = 0,
            _reserved7: u1 = 0,
            /// Update DMA request enable
            UDE: u1 = 0,
            /// Capture/Compare 1 DMA request enable
            CC1DE: u1 = 0,
            /// Capture/Compare 2 DMA request enable
            CC2DE: u1 = 0,
            /// Capture/Compare 3 DMA request enable
            CC3DE: u1 = 0,
            /// Capture/Compare 4 DMA request enable
            CC4DE: u1 = 0,
            _reserved13: u1 = 0,
            /// Trigger DMA request enable
            TDE: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));

        /// address: 0x40000410
        /// status register
        pub const SR = @as(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1 = 0,
            /// Capture/compare 1 interrupt flag
            CC1IF: u1 = 0,
            /// Capture/Compare 2 interrupt flag
            CC2IF: u1 = 0,
            /// Capture/Compare 3 interrupt flag
            CC3IF: u1 = 0,
            /// Capture/Compare 4 interrupt flag
            CC4IF: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger interrupt flag
            TIF: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            /// Capture/Compare 1 overcapture flag
            CC1OF: u1 = 0,
            /// Capture/compare 2 overcapture flag
            CC2OF: u1 = 0,
            /// Capture/Compare 3 overcapture flag
            CC3OF: u1 = 0,
            /// Capture/Compare 4 overcapture flag
            CC4OF: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x10));

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @as(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1 = 0,
            /// Capture/compare 1 generation
            CC1G: u1 = 0,
            /// Capture/compare 2 generation
            CC2G: u1 = 0,
            /// Capture/compare 3 generation
            CC3G: u1 = 0,
            /// Capture/compare 4 generation
            CC4G: u1 = 0,
            _reserved5: u1 = 0,
            /// Trigger generation
            TG: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x14));

        /// address: 0x40000418
        /// capture/compare mode register 1 (output mode)
        pub const CCMR1_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Output compare 1 fast enable
            OC1FE: u1 = 0,
            /// Output compare 1 preload enable
            OC1PE: u1 = 0,
            /// Output compare 1 mode
            OC1M: u3 = 0,
            /// Output compare 1 clear enable
            OC1CE: u1 = 0,
            /// Capture/Compare 2 selection
            CC2S: u2 = 0,
            /// Output compare 2 fast enable
            OC2FE: u1 = 0,
            /// Output compare 2 preload enable
            OC2PE: u1 = 0,
            /// Output compare 2 mode
            OC2M: u3 = 0,
            /// Output compare 2 clear enable
            OC2CE: u1 = 0,
            /// Output Compare 1 mode - bit 3
            OC1M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 2 mode - bit 3
            OC2M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x40000418
        /// capture/compare mode register 1 (input mode)
        pub const CCMR1_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 selection
            CC1S: u2 = 0,
            /// Input capture 1 prescaler
            IC1PSC: u2 = 0,
            /// Input capture 1 filter
            IC1F: u4 = 0,
            /// Capture/compare 2 selection
            CC2S: u2 = 0,
            /// Input capture 2 prescaler
            IC2PSC: u2 = 0,
            /// Input capture 2 filter
            IC2F: u4 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x18));

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output mode)
        pub const CCMR2_Output = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Output compare 3 fast enable
            OC3FE: u1 = 0,
            /// Output compare 3 preload enable
            OC3PE: u1 = 0,
            /// Output compare 3 mode
            OC3M: u3 = 0,
            /// Output compare 3 clear enable
            OC3CE: u1 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Output compare 4 fast enable
            OC4FE: u1 = 0,
            /// Output compare 4 preload enable
            OC4PE: u1 = 0,
            /// Output compare 4 mode
            OC4M: u3 = 0,
            /// Output compare 4 clear enable
            OC4CE: u1 = 0,
            /// Output Compare 3 mode - bit 3
            OC3M_3: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            /// Output Compare 4 mode - bit 3
            OC4M_3: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input mode)
        pub const CCMR2_Input = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3 selection
            CC3S: u2 = 0,
            /// Input capture 3 prescaler
            IC3PSC: u2 = 0,
            /// Input capture 3 filter
            IC3F: u4 = 0,
            /// Capture/Compare 4 selection
            CC4S: u2 = 0,
            /// Input capture 4 prescaler
            IC4PSC: u2 = 0,
            /// Input capture 4 filter
            IC4F: u4 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x1c));

        /// address: 0x40000420
        /// capture/compare enable register
        pub const CCER = @as(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output enable
            CC1E: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1P: u1 = 0,
            _reserved2: u1 = 0,
            /// Capture/Compare 1 output Polarity
            CC1NP: u1 = 0,
            /// Capture/Compare 2 output enable
            CC2E: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2P: u1 = 0,
            _reserved6: u1 = 0,
            /// Capture/Compare 2 output Polarity
            CC2NP: u1 = 0,
            /// Capture/Compare 3 output enable
            CC3E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3P: u1 = 0,
            _reserved10: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC3NP: u1 = 0,
            /// Capture/Compare 4 output enable
            CC4E: u1 = 0,
            /// Capture/Compare 3 output Polarity
            CC4P: u1 = 0,
            _reserved14: u1 = 0,
            /// Capture/Compare 4 output Polarity
            CC4NP: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x20));

        /// address: 0x40000424
        /// counter
        pub const CNT = @as(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16 = 0,
            /// High counter value (TIM2 only)
            CNT_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x24));

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @as(*volatile MmioInt(32, u16), @ptrFromInt(base_address + 0x28));

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @as(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16 = 0,
            /// High Auto-reload value (TIM2 only)
            ARR_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x2c));

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1 value
            CCR1_L: u16 = 0,
            /// High Capture/Compare 1 value (TIM2 only)
            CCR1_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x34));

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2 value
            CCR2_L: u16 = 0,
            /// High Capture/Compare 2 value (TIM2 only)
            CCR2_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x38));

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16 = 0,
            /// High Capture/Compare value (TIM2 only)
            CCR3_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x3c));

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @as(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16 = 0,
            /// High Capture/Compare value (TIM2 only)
            CCR4_H: u16 = 0,
        }), @ptrFromInt(base_address + 0x40));

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @as(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// DMA burst length
            DBL: u5 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x48));

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @as(*volatile Mmio(32, packed struct {
            /// DMA register for burst accesses
            DMAB: u16 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4c));

        /// address: 0x40000450
        /// TIM option register
        pub const OR1 = @as(*volatile Mmio(32, packed struct {
            /// IOCREF_CLR
            IOCREF_CLR: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x50));

        /// address: 0x40000460
        /// TIM alternate function option register 1
        pub const AF1 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            /// External trigger source selection
            ETRSEL: u4 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x60));

        /// address: 0x40000468
        /// TIM alternate function option register 1
        pub const TISEL = @as(*volatile Mmio(32, packed struct {
            /// TI1SEL
            TI1SEL: u4 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            /// TI2SEL
            TI2SEL: u4 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x68));
    };

    /// System configuration controller
    pub const VREFBUF = struct {
        pub const base_address = 0x40010030;

        /// address: 0x40010030
        /// VREFBUF control and status register
        pub const CSR = @as(*volatile Mmio(32, packed struct {
            /// Voltage reference buffer mode enable
            /// This bit is used to enable the voltage reference buffer mode.
            ENVR: u1 = 0,
            /// High impedance mode
            /// This bit controls the analog switch to connect or not the VREF+ pin.
            /// Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR
            /// bit configuration.
            HIZ: u1 = 1,
            _reserved2: u1 = 0,
            /// Voltage reference buffer ready
            VRR: u1 = 0,
            /// Voltage reference scale
            /// These bits select the value generated by the voltage reference buffer. Other:
            /// Reserved
            VRS: u3 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40010034
        /// VREFBUF calibration control register
        pub const CCR = @as(*volatile Mmio(32, packed struct {
            /// Trimming code
            /// These bits are automatically initialized after reset with the trimming value
            /// stored in the Flash memory during the production test. Writing into these bits
            /// allows to tune the internal reference buffer voltage.
            TRIM: u6 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));
    };

    /// MCU debug component
    pub const DBG = struct {
        pub const base_address = 0x40015800;

        /// address: 0x40015800
        /// DBGMCU_IDCODE
        pub const IDCODE = @as(*volatile Mmio(32, packed struct {
            /// Device identifier
            DEV_ID: u12 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            /// Revision identifie
            REV_ID: u16 = 0,
        }), @ptrFromInt(base_address + 0x0));

        /// address: 0x40015804
        /// Debug MCU configuration register
        pub const CR = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            /// Debug Stop mode
            DBG_STOP: u1 = 0,
            /// Debug Standby mode
            DBG_STANDBY: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            _reserved11: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x4));

        /// address: 0x40015808
        /// Debug MCU APB1 freeze register1
        pub const APB_FZ1 = @as(*volatile Mmio(32, packed struct {
            /// TIM2 counter stopped when core is halted
            DBG_TIM2_STOP: u1 = 0,
            /// TIM3 counter stopped when core is halted
            DBG_TIM3_STOP: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            /// RTC counter stopped when core is halted
            DBG_RTC_STOP: u1 = 0,
            /// Window watchdog counter stopped when core is halted
            DBG_WWDG_STOP: u1 = 0,
            /// Independent watchdog counter stopped when core is halted
            DBG_IWDG_STOP: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            _reserved15: u1 = 0,
            _reserved16: u1 = 0,
            _reserved17: u1 = 0,
            _reserved18: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            /// I2C1 SMBUS timeout counter stopped when core is halted
            DBG_I2C1_STOP: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0x8));

        /// address: 0x4001580c
        /// Debug MCU APB1 freeze register 2
        pub const APB_FZ2 = @as(*volatile Mmio(32, packed struct {
            _reserved0: u1 = 0,
            _reserved1: u1 = 0,
            _reserved2: u1 = 0,
            _reserved3: u1 = 0,
            _reserved4: u1 = 0,
            _reserved5: u1 = 0,
            _reserved6: u1 = 0,
            _reserved7: u1 = 0,
            _reserved8: u1 = 0,
            _reserved9: u1 = 0,
            _reserved10: u1 = 0,
            /// TIM1 counter stopped when core is halted
            DBG_TIM1_STOP: u1 = 0,
            _reserved12: u1 = 0,
            _reserved13: u1 = 0,
            _reserved14: u1 = 0,
            /// DBG_TIM14_STOP
            DBG_TIM14_STOP: u1 = 0,
            _reserved16: u1 = 0,
            /// DBG_TIM16_STOP
            DBG_TIM16_STOP: u1 = 0,
            /// DBG_TIM17_STOP
            DBG_TIM17_STOP: u1 = 0,
            _reserved19: u1 = 0,
            _reserved20: u1 = 0,
            _reserved21: u1 = 0,
            _reserved22: u1 = 0,
            _reserved23: u1 = 0,
            _reserved24: u1 = 0,
            _reserved25: u1 = 0,
            _reserved26: u1 = 0,
            _reserved27: u1 = 0,
            _reserved28: u1 = 0,
            _reserved29: u1 = 0,
            _reserved30: u1 = 0,
            _reserved31: u1 = 0,
        }), @ptrFromInt(base_address + 0xc));
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @as(*volatile Mmio(size, PackedT), @ptrFromInt(addr));
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @as(PackedT, @bitCast(addr.raw));
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @as(IntT, @bitCast(val));
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @as(T, @truncate(addr.raw));
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @as(*volatile MmioInt(size, T), @ptrFromInt(addr));
}

// This is only necessary because of a dubious design decision implemented
// in zig 0.10, disallowing @bitCasting between ints and enums:
// https://github.com/ziglang/zig/issues/3647
inline fn fromInt(comptime T: type, value: anytype) T {
    return switch (@typeInfo(T)) {
        .Enum => @as(T, @enumFromInt(value)),
        else => @as(T, @bitCast(value)),
    };
}

pub const InterruptVector = extern union {
    C: *const fn () callconv(.C) void,
    Naked: *const fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};

//[[ ######################### END OF GENERATED CODE ######################### ]]
